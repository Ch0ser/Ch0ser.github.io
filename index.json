[{"content":" 学习参考的教程为Bash 脚本教程 - 网道，非常感谢开源工作者的贡献！\n如使用到该教程，可随意使用但请标明出处\nBash简介\rBash 简介 - Bash 脚本教程 - 网道\n该部分详见上述网站，都是些基本性的概念\nBash的基本语法\r1.echo命令\r1 2 3 # echo命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。 $ echo hello world hello world 如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。\n1 2 3 4 5 6 7 8 $ echo \u0026#34;\u0026lt;HTML\u0026gt; \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt;Page Title\u0026lt;/TITLE\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; Page body. \u0026lt;/BODY\u0026gt; \u0026lt;/HTML\u0026gt;\u0026#34; 上面例子中，echo可以原样输出多行文本。\n但是，其实不好用，因为除非你一口气全部复制进命令行，不然你一回车就会被截断。\n所以输出多行更推荐用cat：\n1 2 3 4 5 6 7 8 9 10 11 # cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; 表示从下一行开始读取内容，直到遇到单独一行的 EOF。 cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026lt;HTML\u0026gt; \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt;Page Title\u0026lt;/TITLE\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; Page body. \u0026lt;/BODY\u0026gt; \u0026lt;/HTML\u0026gt; EOF #结束符号 1.1 -n参数\r默认情况下，echo输出的文本末尾会有一个回车符。-n参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。\n1 2 $ echo -n hello world hello world$ 上面例子中，world后面直接就是下一行的提示符$。\n1 2 3 4 5 $ echo a;echo b a b $ echo -n a;echo b ab 上面例子中，-n参数可以让两个echo命令的输出连在一起，出现在同一行。\n1.2-e参数\r-e参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符\\n）。如果不使用-e参数，即默认情况下，引号会让特殊字符变成普通字符，echo不解释它们，原样输出。\n1 2 3 4 5 6 7 8 9 10 11 12 $ echo \u0026#34;Hello\\nWorld\u0026#34; Hello\\nWorld # 双引号的情况 $ echo -e \u0026#34;Hello\\nWorld\u0026#34; Hello World # 单引号的情况 $ echo -e \u0026#39;Hello\\nWorld\u0026#39; Hello World 上面代码中，-e参数使得\\n解释为换行符，导致输出内容里面出现换行。\n2.命令格式\r命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。\n1 $ command [ arg1 ... [ argN ]] 上面代码中，command是具体的命令或者一个可执行文件，arg1 ... argN是传递给命令的参数，它们是可选的。\n1 $ ls -l 上面这个命令中，ls是命令，-l是参数。\n有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的-l。同一个配置项往往有长和短两种形式，比如-l是短形式，--list是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。\n1 2 3 4 5 # 短形式 $ ls -r # 长形式 $ ls --reverse 上面命令中，-r是短形式，--reverse是长形式，作用完全一样。前者便于输入，后者便于理解。\nBash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。\n1 2 3 4 5 $ echo foo bar # 等同于 $ echo foo \\ bar 3.空格\rBash 使用空格（或 Tab 键）区分不同的参数。\n1 $ command foo bar 上面命令中，foo和bar之间有一个空格，所以 Bash 认为它们是两个参数。\n如果参数之间有多个空格，Bash 会自动忽略多余的空格。\n1 2 $ echo this is a test this is a test 上面命令中，a和test之间有多个空格，Bash 会忽略多余的空格。\n4.分号\r分号（;）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。\n1 $ clear; ls 上面例子中，Bash 先执行clear命令，执行完成后，再执行ls命令。\n注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。\n5.命令的组合符\u0026amp;\u0026amp;和||\r除了分号，Bash 还提供两个命令组合符\u0026amp;\u0026amp;和||，允许更好地控制多个命令之间的继发关系。\n1 2 # 肯定先继 Command1 \u0026amp;\u0026amp; Command2 上面命令的意思是，如果Command1命令运行成功，则继续运行Command2命令。\n1 2 # 否定先继 Command1 || Command2 上面命令的意思是，如果Command1命令运行失败，则继续运行Command2命令。\n下面是一些例子。\n1 $ cat filelist.txt ; ls -l filelist.txt 上面例子中，只要cat命令执行结束，不管成功或失败，都会继续执行ls命令。\n1 $ cat filelist.txt \u0026amp;\u0026amp; ls -l filelist.txt 上面例子中，只有cat命令执行成功，才会继续执行ls命令。如果cat执行失败（比如不存在文件flielist.txt），那么ls命令就不会执行。\n1 $ mkdir foo || mkdir bar 上面例子中，只有mkdir foo命令执行失败（比如foo目录已经存在），才会继续执行mkdir bar命令。如果mkdir foo命令执行成功，就不会创建bar目录了。\n6.type 命令\rBash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？\ntype命令用来判断命令的来源。\n1 2 3 4 $ type echo echo is a shell builtin $ type ls ls is hashed (/bin/ls) 上面代码中，type命令告诉我们，echo是内部命令，ls是外部程序（/bin/ls）。\ntype命令本身也是内置命令。\n1 2 $ type type type is a shell builtin 如果要查看一个命令的所有定义，可以使用type命令的-a参数。\n1 2 3 4 $ type -a echo echo is shell builtin echo is /usr/bin/echo echo is /bin/echo 上面代码表示，echo命令既是内置命令，也有对应的外部程序。\ntype命令的**-t参数**，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。\n1 2 3 4 $ type -t bash file $ type -t if keyword 上面例子中，bash是文件，if是关键词。\n7.快捷键\rBash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见《行操作》一章。\nCtrl + L：清除屏幕并将当前行移到页面顶部。 Ctrl + C：中止当前正在执行的命令。 Shift + PageUp：向上滚动。 Shift + PageDown：向下滚动。 Ctrl + U：从光标位置删除到行首。 Ctrl + K：从光标位置删除到行尾。 Ctrl + W：删除光标位置前一个单词。 Ctrl + D：关闭 Shell 会话。 ↑，↓：浏览已执行命令的历史记录。 除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入tou，然后按一下 Tab 键，Bash 会自动补上ch。\n除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让你选择。\n","date":"2025-10-15T16:10:33Z","image":"https://ch0ser.github.io/images/Cloud.png","permalink":"https://ch0ser.github.io/p/bash_introgrammar/","title":"Bash_intro\u0026grammar"},{"content":"本文是本人学习 Linux 命令行 Bash 的基本用法和脚本编程的笔记汇总。\n核心参考教程：Bash 脚本教程 - 网道\n这是一个互联网开源文档，非常感谢开源创作者的贡献。\nBash 介绍和基本语法 ","date":"2025-10-15T16:02:47Z","image":"https://ch0ser.github.io/images/Cat\u0026Tree.png","permalink":"https://ch0ser.github.io/p/bash/","title":"Bash"},{"content":"WindRanger\u0026amp;BeaconFuzz\rWindRanger 是一个基于 BeaconFuzz 算法的定向模糊测试工具，发表于 ICSE 2022，旨在高效引导模糊测试到达目标代码（如漏洞触发点）。其核心创新是 BeaconFuzz 策略，通过动态识别关键代码块（Beacon）来优化路径探索。\n1. WindRanger 概述\r1.1 是什么？\rWindRanger 是一个灰盒（Greybox）定向模糊测试工具，基于 AFL++ 改进，专门用于快速触发特定代码位置（如已知漏洞点）。 主要用途： 漏洞复现（如 CVE 测试） 补丁验证（检查修复是否有效） 关键代码覆盖测试 1.2 核心优势\r对比对象 传统定向模糊测试（如 AFLGo） WindRanger 引导方式 静态控制流距离（固定优先级） 动态 Beacon 识别（自适应优化） 路径探索 容易陷入局部最优（长路径依赖） 通过 Beacon 发现“捷径” 效率 较慢（需大量变异） 更快收敛到目标 2. BeaconFuzz：WindRanger 的核心算法\r2.1 BeaconFuzz 的核心思想\rBeaconFuzz 的核心是 Deviation Basic Blocks（偏离基本块，即 Beacon），它通过以下方式优化模糊测试：\n静态分析阶段： 识别程序中能显著缩短到目标代码距离的分支（即 Beacon 块）。 例如：if (x \u0026gt; 100) 的分支比 else 分支更接近目标，则 x \u0026gt; 100 被标记为 Beacon。 动态执行阶段： 优先变异那些能触发 Beacon 块的输入，快速逼近目标。 2.2 BeaconFuzz 的工作流程\r（1）静态分析（由 cbi 工具完成）\r输入： 目标程序的 LLVM 字节码（.bc 文件） 用户指定的目标代码行（如 decompile.c:398） 步骤： 构建控制流图（CFG）：分析程序的基本块（Basic Block）和跳转关系。 计算静态距离：对每个基本块，计算其到目标代码的最短路径步数。 识别 Beacon 块：标记能显著缩短距离的关键分支（如 if-else 中的某个分支）。 （2）动态模糊测试（由改进的 afl-fuzz 执行）\r种子调度： 对输入队列中的种子，根据其是否触发 Beacon 动态调整优先级。 奖励机制：触发 Beacon 的种子会被更频繁地变异。 变异策略： 结合 AFL 的变异方式（如位翻转、算术变异），但偏向生成能覆盖 Beacon 的输入。 3. WindRanger 和 BeaconFuzz 的关系\r3.1 WindRanger = BeaconFuzz + 工具链实现\r组件 功能 BeaconFuzz 的作用 cbi 静态分析，插桩 识别 Beacon 块，计算距离 afl-fuzz 动态模糊测试 基于 Beacon 动态调整种子优先级 beacon.txt 记录 Beacon 触发情况 用于调试和优化引导策略 BeaconFuzz 是windranger的核心导航算法，负责找到最优路径。 其他组件（如插桩、崩溃检测）是剩余fuzz流程的补全。 ","date":"2025-10-14T14:59:29Z","image":"https://ch0ser.github.io/images/ChillOcean.png","permalink":"https://ch0ser.github.io/p/beaconwindranger/","title":"Beacon\u0026WindRanger"},{"content":"DGF Tool Energy Allocation Strategies\rDGF工具能量分配策略一览\nAFL\r本节聚焦AFL 及其衍生工具在 seed fuzzing 过程中的能量分配策略（power schedule），即决定“从某个种子输入生成多少额外测试用例”的算法。以 AFLFast 提供的六种策略为基准，给出简明对比和使用建议。\n参考：https://github.com/lhxdz/afl-mix?tab=readme-ov-file\nps：冷热程度指有多少其他输入已经跑过同一条路径\nAFL 标志 策略名称 能量公式 核心思想 简言之 -p fast（默认） FAST 指数放大低频路径能量，快速收敛 偏袒“冷门”路径，给的测试用例更多；热门路径反之 -p coe COE (cut-off exponential) 高频路径直接“断电”，资源全给罕见路径 检测到某路径太热门（超过平均值）就直接断电（0 个新用例），冷门路径才继续深究 -p explore EXPLORE 线性均衡，与路径频率无关 一视同仁，每个种子按 AFL 原始评分给能量，不看冷热。 -p quad QUAD 二次曲线惩罚高频路径 冷门路径奖励得更快（二次曲线），热门路径被二次方打压。 -p lin LIN 线性惩罚高频路径 冷门路径奖励、热门路径惩罚都按线性比例，节奏比较温柔。 -p exploit EXPLOIT (原生 AFL) 恒定能量，仅依赖 AFL 原始性能分 只按“跑得快不快、覆盖新不新”给能量，完全不考虑路径冷热。 符号释义\nα(i)：AFL 原生性能评分（执行时间、块转移覆盖率等） β：全局常数，防止能量爆炸 s(i)：种子 i 被 fuzz 的次数 f(i)：触发与 i 相同路径的输入总量 μ：所有路径的平均输入数 快速实践指南\n单机 fuzz：保持默认 -p fast 即可。 并行集群： master 用 -p exploit 稳定产生种子； slaves 组合 -p coe / -p fast / -p explore 以覆盖低频路径。 若使用 AFL++，可直接在命令行追加对应 -p 参数，无需额外补丁。 AFLGo\r与追求广覆盖的 AFL/AFLFast 不同，AFLGo 专为**定向灰盒模糊测试（DGF）设计，其能量分配核心在于“越靠近目标代码的种子，获得的 fuzz 轮次越多”。算法基于模拟退火（Simulated Annealing）**动态调节，公式与参数如下表所示。\nAFLGo 变量 定义/作用 d(s,T) 种子 s 到目标集合 T 的**平均基本块距离（**静态分析得出，越小越近） d̃(s,T) 归一化距离：d̃ = d / d_max ∈ [0,1]，0 表示最近，1 表示最远 T_exp 退火温度：T_exp = 20^(−t/tₓ)，t 为已用时间，tₓ 为“利用阶段”起始参数 p_afl(s) AFL 原生能量（由执行速度、路径稀有度决定） p(s,T) 退火比例因子：p = (1−d̃)·(1−T_exp) + 0.5·T_exp E(s,T) 最终能量：E = p_afl(s) · 2^(2 log₂(MAX)·(p−0.5))，MAX≈30 根据格式可以得到能量分配规则\n在时间较小时，温度影响较大，而距离影响较小 随着时间推移，T_exp 递减，距离影响较大 因此系统从“全局探索”逐步过渡到“局部深究”。 快速实践\n编译：afl-clang-fast + -targets= 生成含距离信息的二进制。 运行：afl-fuzz 追加 -z targets.txt 即启用 AFLGo；无需额外 -p 参数。 并行：官方脚本自动为各实例划分不同目标区间，避免能量冲突。 Beacon\rBeacon 是面向“混合符号执行引导的定向模糊测试”工具，核心目标是在最短 CPU 时间内到达用户指定的目标地址/断言。其能量分配策略以距离-稀缺联合权重（Distance-Scarcity Weight, DSW）为核心，同时引入梯度冷却（Gradient Cooling）机制抑制过度消耗。\n关键公式与参数如下表所示。\nBeacon 符号 定义/作用 d(s,t) 种子 s 到目标 t 的动态最短路径距离（插桩实时计算，单位：基本块数） r(s) 稀缺度：r(s)=1/(hit(s)+ε)，hit(s) 为触发该种子路径的输入次数 α 距离权重系数，默认 0.7（用户可通过 --alpha 调整） β 稀缺权重系数，默认 0.3（满足 α+β=1） w(s,t) 联合权重：w(s,t)=α·d̃(s,t)⁻¹+β·r(s)；d̃ 为归一化距离 T(k) 梯度冷却温度：T(k)=w_max·e^(−k/k₀)，k 为当前轮次，k₀ 为冷却常数 E(s,t) 最终能量：E(s,t)=E₀·w(s,t)/T(k)，E₀ 为基准能量（默认 1000） 能量分配规则总结\n越靠近目标（d 越小）且越罕见（r 越大）的种子，联合权重 w 越高； 随着 fuzz 轮次 k 增加，温度 T(k) 指数下降 → 高权重种子能量被进一步放大； 当 T(k) 接近 0 时，能量几乎只流向离目标最近的稀缺路径。 快速实践\n编译：clang-beacon -targets=targets.txt 生成带距离插桩的二进制。 运行：./beacon-fuzz -i in -o out -t targets.txt [可选 --alpha=0.6]。 并行：官方脚本 beacon-parallel.py 自动为各实例分配不同 k₀ 值，避免冷却同步。 WindRanger\rWindRanger 是面向多目标定向灰盒模糊测试（DGF）的工具，其核心创新在于“多级优先级队列 + 距离驱动能量分配”机制，可在一次 fuzzing 会话中同时逼近多个目标（偏差基本块 DBB），并确保测试资源向最易触发新路径的种子快速收敛。关键公式与参数如下表所示。\nWindRanger 符号 定义 / 作用 DBB Deviation Basic Block：待覆盖的目标基本块 d(s, DBB) 种子 s 到目标 DBB 的静态最短路径距离（单位：基本块数） L(s, DBB) 为每个 DBB 维护的种子列表，按 d(s, DBB) 升序排序 Q₁ 一级优先级队列：每个 DBB 对应列表头部种子（距离最近） Q₂ 二级优先级队列：同一 DBB 列表中剩余种子 E(s) 种子实时能量：E(s) = E₀ · (1 / (d(s, DBB)+ε))，ε 防止除零 T_select 队列选择策略：先耗尽 Q₁ 再取 Q₂，确保最近种子优先突变 能量分配规则总结\n距离越短 -\u0026gt; 排序越靠前 -\u0026gt; 进入 Q₁ -\u0026gt; 获得高能量 E(s)； 距离越远 -\u0026gt;落入 Q₂ -\u0026gt; 能量随 d 线性衰减，甚至长期不被选中； 每轮 fuzz 只从当前最高优先级队列取种子，形成“探索→利用”过渡。 快速实践\n编译：clang-windranger -targets=targets.txt 生成带 DBB 距离的二进制。 运行：./windranger-fuzz -i in -o out -t targets.txt 并行：官方脚本自动为不同 DBB 建立独立队列，避免队列间饥饿。 DAFL\rDAFL（Data-dependency Aware Fuzzing with Lightweight slicing）是以数据依赖为核心的定向灰盒模糊测试工具。其能量分配机制在传统 AFL 能量公式基础上，引入语义相关性评分（semantic-relevance score）进行比例再缩放，使 fuzz 资源优先流向与漏洞触发点数据依赖更紧密的种子。\n关键公式与参数如下表所示。\nDAFL 符号 定义 / 作用 scr_s 种子 s 的语义相关性评分（由静态数据依赖切片计算得出，越大越相关） scr_avg 当前种子池内所有种子的平均语义相关性评分 E_AFL(s) AFL 原生能量（基于执行速度、路径稀有度等 AFL 传统因子） E_DAFL(s) DAFL 调整后能量：E_DAFL(s) = (scr_s / scr_avg) × E_AFL(s) ε 极小常数，避免除零 种子池排序 每轮按 scr_s 降序重排，循环队列指针不重置，防止饥饿 能量分配规则总结\n数据依赖越紧密（scr_s 越高）的种子，获得 E_DAFL(s) 线性放大； 依赖关系稀疏（scr_s 低）的种子，能量被等比例压缩； 每轮重新排序队列保证高相关性种子始终优先，且不会产生饥饿。 快速实践\n编译：afl-clang-dafl -targets=targets.txt 生成带数据依赖插桩的二进制。 运行：./dafl-fuzz -i in -o out -t targets.txt（无需额外 -p 参数）。 并行：官方脚本 dafl-parallel.py 为不同目标 DBB 维护独立 scr_avg，避免跨目标干扰。 已知效果\n与 AFLGo 相比，基于数据依赖的能量分配平均提速 1.27×； 与原生 AFL 相比，DAFL 平均复现时间缩短 1.93×，并解决 AFL 无法触达的 4 个超时案例。 DAFL实验消融/对比配置\r配置名称 数据依赖切片 语义相关评分 scr_s 能量公式 种子池策略 适用场景 / 研究目的 DAFL_noasan 是 是 E = (scr_s/scr_avg)·E_AFL 动态重排 评估 ASan 运行时开销对能量分配的影响 DAFL_naive 否 否（直接scr_s=1） E = E_AFL 动态重排 退化为传统 AFL，验证切片+评分带来的增益 DAFL_selIns 是 是 E = (scr_s/scr_avg)·E_AFL 动态重排 仅插桩数据依赖相关的指令，评估插桩开销与精度权衡 DAFL_semRel 否 是 E = (scr_s/scr_avg)·E_AFL 动态重排 关闭切片，验证语义评分单独贡献 DAFL_seedpool 是 是 E = (scr_s/scr_avg)·E_AFL 固定大小（1000） 评估动态种子池策略对覆盖率的影响 DAFL_energy 否 是 仅能量公式有效，不重新排序 无重排 验证排序机制与能量放大机制的独立贡献 使用示例\n1 2 3 4 5 6 7 8 9 10 11 # 完整 DAFL CC=afl-clang-dafl make ./dafl-fuzz -i in -o out -t targets.txt # 关闭 ASan AFL_NO_ASAN=1 CC=afl-clang-dafl make ./dafl-fuzz -i in -o out -t targets.txt # 退化为 AFL（naive） AFL_DAFL_NAIVE=1 CC=afl-clang-dafl make ./dafl-fuzz -i in -o out -t targets.txt ","date":"2025-10-14T14:47:25Z","image":"https://ch0ser.github.io/images/RiverInTrees.png","permalink":"https://ch0ser.github.io/p/dgf-tool-energy-allocation-strategies/","title":"DGF Tool Energy Allocation Strategies"},{"content":"QuickFuzz\rFuzz入门，学习参考：Baby Fuzz · Home，BV1ZM4m1R7gZ\n模糊测试理论与工具实践\r总览\r模糊测试又称为fuzzing，是一种软件测试技术。其核心概念为自动产生随机输入到一个程序中，并监视程序异常，如崩溃、断言失败，以发现可能的程序错误。\n举例\r测试.c:\n1 2 3 4 5 6 7 8 9 10 11 12 // gcc -o test test.c #include \u0026lt;unistd.h\u0026gt; int main() { char input[8] = {0}; read(STDIN_FILENO, input, 8); if (input[0] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; input[1] == \u0026#39;B\u0026#39;) // (1) *((unsigned int *)0) = 0xdeadbeef; // (2)，将空指针赋值为0xdeadbeef，引发程序崩溃 write(STDOUT_FILENO, input, 8); return 0; } 模糊器.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import subprocess target = \u0026#39;./test\u0026#39; inps = [\u0026#39;AA\u0026#39;, \u0026#39;BB\u0026#39;, \u0026#39;BA\u0026#39;, \u0026#39;AB\u0026#39;] for inp in inps: // 不断测试哪些输入会引发程序崩溃 try: subprocess.run([target], input=inp.encode(), capture_output=True, check=True) except subprocess.CalledProcessError: # (1) print(f\u0026#34;bug found with input: \u0026#39;{inp}\u0026#39;\u0026#34;) # (output) # bug found with input: \u0026#39;AB\u0026#39; 内部架构\r在执行时会因为不同的条件执行不同的程序码，而不同的条件主要if就是定义\n1 2 3 4 if (a == 1 \u0026amp;\u0026amp; b == 2) puts(\u0026#34;condition 1\u0026#34;); else puts(\u0026#34;condition 2\u0026#34;); IDA pro生产出来的指令级别的控制流图(CFG)\nfuzzing流程大致可以拆成三个组件分别为：\n1.种子选择、2.突变、3.覆盖范围。\n举例：\n测试.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // gcc -o test test.c #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char input[8] = {0}; read(STDIN_FILENO, input, 8); if (input[0] == \u0026#39;A\u0026#39;) { puts(\u0026#34;AAA\u0026#34;); if (input[1] == \u0026#39;B\u0026#39;) { puts(\u0026#34;BBB\u0026#34;); if (input[2] == \u0026#39;C\u0026#39;) { *((unsigned int *)0) = 0xdeadbeef; // bug } } } return 0; } 测试器.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import subprocess import random target = \u0026#39;./test\u0026#39; inps = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] # 语料库 count = 1 while True: inp = inps[0] # 种子选择演算法比较简单，使用最新的的种子作为下一个输入 inp += random.choice([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) # 变异演算会挑选出来的种子加上一个随机字元作为最终的输入。 del inps[0] #加一个删一个，保证下次取的是下一个 count += 1 #记录处理了多少个输入 try: comp = subprocess.run([target], input=inp.encode(), capture_output=True, check=True) if comp.stdout != b\u0026#39;\u0026#39;: inps.append(inp) # 如果有输出的话则代表此输入为有趣 except subprocess.CalledProcessError: print(f\u0026#34;bug found with input: \u0026#39;{inp}\u0026#39;\u0026#34;) break if count % 100 == 0 or len(inps) == 0: # 定期打乱语料库,避免变异效果不好导致输入无法取得新的覆盖范围 inps = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] 模糊器的好坏，通常是：\n种子选择是否能挑出真正有意义的种子 变异的随机是否有效率 覆盖实现的方式是否会造成大量的开销。 AFL(American Fuzz Loop)\r– 简介 \u0026amp; 安装\n以下是一些比较有名的开源模糊测试工具：\nAmerican Fuzzy Lop (AFL): AFL 是一个高效的模糊测试工具 libFuzzer: libFuzzer 是 LLVM/Clang 提供的一个模糊测试引擎，它可以轻松地集成到现有的代码中 Syzkaller: Syzkaller 是一个专注于系统调用接口的模糊测试工具，它可以自动生成各种系统调用序列，并对内核进行测试以发现漏洞和错误。 OSS-Fuzz: OSS-Fuzz旨在通过自动化模糊测试发现开源软件中的安全漏洞和错误。 Fuzz方式\rAFL有两种fuzz途径：\n开源软件：AFL软件进行编译的同时进行插桩，以方便fuzz 闭源软件：配合QEMU直接对闭源的二进制代码进行fuzz 环境搭建\r安装\rLinux包管理(deb)：\n1 $ sudo apt install afl++ 源码编译安装 ：\n下载源码自行编译：(推荐安装AFL++，AFl的话如果开ASAN可能有问题)\n1 2 3 4 $ git clone https://github.com/AFLplusplus/AFLplusplus.git $ cd AFLplusplus $ make $ sudo make install AFL(American Fuzz Loop)\r插桩（instrumentation）\r在保证原程序逻辑的完整性下，在程序中插入一些程序码来采集运行期间的执行状态。\n1 2 3 4 5 6 7 8 9 int test_var = 0; // original (1) void b() { ...; } void a() { ...; } // instrumented (2) void b() { printf(\u0026#34;test_var: %d\\n\u0026#34;, test_var); ...; } void a() { printf(\u0026#34;test_var: %d\\n\u0026#34;, test_var); ...; } 特点：\r插桩的对象通常都具有相同的属性或类别涉及所有的功能、所有的基本块，比较少针对单一目标。 插桩的程序代码通常只有几行汇编代码，并且不会做太复杂的操作 在模糊器中，插桩被用来进行覆盖，那么记录多少程序码被执行到。 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int had_exec[100] = {0}; void a() { had_exec[0] = 1; // (1) // ... } void b() { had_exec[1] = 1; ...; } void c() { had_exec[2] = 1; ...; } int main() { // ... if (had_exec[0]) // (2) puts(\u0026#34;function a had been called\u0026#34;); } Demo\r演示\n测试程序test.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int a, idx; char buf[100]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); buf[idx] = \u0026#39;\\0\u0026#39;; read(0, \u0026amp;a, 0x2); if (a == 0xdead) *(int *)0 = 0xdeadbeef; return 0; } afl-gcc\r1 2 $ export AFL_USE_ASAN=1 $ afl-gcc -fsanitize=address -o test test.c 最后会我们的命令会变成这样 gcc选用afl的汇编器来编译\n1 $ gcc -fsanitize=address -o test test.c -B ~/fuzz/AFLplusplus -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 有趣的是-B ~/fuzz/AFL，gcc 会尝试在这里寻找路径工具链中的汇编器来执行 1 2 $ ls -al ~/fuzz/AFLplusplus/as $ lrwxrwxrwx 1 lidaxian lidaxian 6 Mar 29 14:53 as -\u0026gt; afl-as afl-as\rafl-as首先会执行函数add_instrumentation()做插桩（对汇编代码），最后执行as做汇编（编译成机械代码）。所以插桩是在编译之后汇编之前。 做完插桩后会执行调整后的参数来汇编新的asm文件，最后产生的执行文件test即是有插桩的版本，简单用objdump就可以看到许多以__afl为前缀的函数(说明已完成插桩)： 1 2 3 4 5 $ objdump -M intel -d test | grep afl 119d: e8 1e 02 00 00 call 13c0 \u0026lt;__afl_maybe_log\u0026gt; 120d: e8 ae 01 00 00 call 13c0 \u0026lt;__afl_maybe_log\u0026gt; 1255: e8 66 01 00 00 call 13c0 \u0026lt;__afl_maybe_log\u0026gt; 12a1: e8 1a 01 00 00 call 13c0 \u0026lt;__afl_maybe_log\u0026gt; afl-fuzz\r1 afl-fuzz -i seed-dir -o out-dir -m none ./test -i - 存放测试用例的资料夹 -o - 搁置执行结果资料夹 -f - 从指定文件读取输入 -t - timeout，执行时间超过的话就会被kill掉 -m - 内存限制，执行时所能使用的内存体上限 -d - 跳过确定性，突变阶段跳过最初的处理 -n - 对没有插桩的目标进行模糊测试 tips：\n运行后遇到一些问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 demian@Friday:~/C_lab/fuzz$ afl-fuzz -i seed-dir -o out-dir -m none ./test~ afl-fuzz++4.09c based on afl by Michal Zalewski and a large online community [+] AFL++ is maintained by Marc \u0026#34;van Hauser\u0026#34; Heuse, Dominik Maier, Andrea Fioraldi and Heiko \u0026#34;hexcoder\u0026#34; Eißfeldt [+] AFL++ is open source, get it at https://github.com/AFLplusplus/AFLplusplus [+] NOTE: AFL++ \u0026gt;= v3 has changed defaults and behaviours - see README.md [+] No -M/-S set, autoconfiguring for \u0026#34;-S default\u0026#34; [*] Getting to work... [+] Using exponential power schedule (FAST) [+] Enabled testcache with 50 MB [+] Generating fuzz data with a length of min=1 max=1048576 [*] Checking core_pattern... [-] Hmm, your system is configured to send core dump notifications to an external utility. This will cause issues: there will be an extended delay between stumbling upon a crash and having this information relayed to the fuzzer via the standard waitpid() API. If you\u0026#39;re just testing, set \u0026#39;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1\u0026#39;. To avoid having crashes misinterpreted as timeouts, please log in as root and temporarily modify /proc/sys/kernel/core_pattern, like so: echo core \u0026gt;/proc/sys/kernel/core_pattern [-] PROGRAM ABORT : Pipe at the beginning of \u0026#39;core_pattern\u0026#39; Location : check_crash_handling(), src/afl-fuzz-init.c:2361 从错误信息来看，系统配置了外部工具来处理核心转储（core dump），这会导致 AFL++ 无法正确处理崩溃信息。\n所以我们要修改系统的 core_pattern 配置。\n首先，运行以下命令查看当前的 core_pattern 配置：\n1 cat /proc/sys/kernel/core_pattern 输出类似于 |/usr/lib/systemd/systemd-coredump %p %u %g %s %t %c %h，说明系统配置了外部工具来处理核心转储。\n然后以 root 用户身份运行以下命令，将 core_pattern 修改为 core：\n1 echo core | sudo tee /proc/sys/kernel/core_pattern 再次查看 core_pattern 配置，确认修改成功：\n1 cat /proc/sys/kernel/core_pattern 如果输出为 core，说明修改成功。\n接下来就可以重新运行 AFL-fuzz。\n1 afl-fuzz -i seed-dir -o out-dir -m none ./test 在创建了相关目录和种子文件后，命令运行成功就能在终端看见如下结果了：\nCrash分析\rout-dir/crashes目录下的内容是引发崩溃的输入。\nSanitizer\r即使程序存在漏洞，也不一定会在执行到有漏洞的程式码时触发异常\n举例：\n1 2 3 char buf[100]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); buf[idx] = \u0026#39;\\0\u0026#39;; // (1) 然而即便会有out-of-bound write 的漏洞发生，但如果buf[101]对应到的地址正好没被使用到，那么fuzzer也不会感兴趣。\n所以我们需要“Sanitizer”来辅助检测程序问题，它是一种用于检测程序中各种错误（如内存错误、数据竞争等）的工具。它通常集成在编译器中，可以在程序运行时检测问题。\n能辅助检测，但是有额外性能和时间需求。\n常见的Sanitizer有：\nAddressSanitizer (+LeakSanitizer) ThreadSanitizer UndefinedBehaviorSanitizer MemorySanitizer AddressSanitizer原理简介\r这个内存检查是如何工作的？\n左侧，蓝色区域是我们分配的内存在右侧\n右侧，Redzones是中毒的内存，访问即报错。\n如果通过启用Address Sanitizer来编译可执行文件，则每次访问内存之前，都会有前缀指令来检查该内存是否为poisoned.如果是，Address Sanitizer 将生成如上所示的诊断报告。\n下图显示该进程正在尝试访问中毒内存，并触发Crash并生成诊断报告。\n堆对象分配\rAddress Sanitizer通过使用它自己的分配实现来替换默认的 Malloc 实现，该实现将对象彼此分开，中间插入有毒内存。\n堆栈变量\r在两个堆栈变量之间插入一些红色区域，因此堆栈红色区域在运行时中毒。\n额外的开销\rCPU 减速通常在 2 倍到 5 倍之间 正常情况下，CPU 速度减慢 2 倍至 3 倍。在某些极端情况下，他们的速度下降了 5 倍。 内存开销 2x–3x AddressSanitizer 使用比本机运行更多的实际内存。确切的开销取决于分配大小。分配越小，开销就越大。 AddressSanitizer 使用更多的堆栈内存。我们看到增长高达 3 倍。 实战演示-libpng\r0x0.编译fuzz目标\rlibpng是开源的png解析库\n1 2 3 4 5 6 $ wget https://nchc.dl.sourceforge.net/project/libpng/libpng16/1.6.36/libpng-1.6.36.tar.xz $ tar xvf libpng-1.6.36.tar.xz $ cd libpng-1.6.36 $ ./autogen.sh $ CC=afl-clang CXX=afl-g++ ./configure --enable-static $ make -j4 --enable-static ： 用于生成静态库，fuzz开源库时会需要\n0x1.准备环境(准备种子)\r获取官网提供的测试集作为输入\n1 2 3 4 $ mkdir fuzz_in fuzz_out $ cd fuzz_in $ wget http://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz $ tar xvf afl_testcases.tgz 0x2.开始fuzz#\r1 $ afl-fuzz -i ../fuzz_in/png/full/images -o ../fuzz_out ../.libs/pngimage @@ ../fuzz_in/png/full/images为afl测试集\n../.libs/pngimage是编译出来的被测试程序\n@@代表测试输入样本\n0x3.报错处理(如果安装在系统上时)\rAFL测试时用到功能需要还没有开启\n1 2 3 4 sudo su echo core \u0026gt;/proc/sys/kernel/core_pattern cd /sys/devices/system/cpu echo performance | tee cpu*/cpufreq/scaling_governor 总结\r使用AFL在linux上fuzz开源软件十分简单 大多数的lib/开源软件的源代码都是可以获取的 在编译时插桩是可行的 在Fuzz时要用ASAN,MSAN,UBSAN 有时最需要花费时间的过程是项目编译 缺失引用的第三方库（lib） 编译过程中的各种错误 不同项目不同的编译方法与各种选项 ","date":"2025-10-14T14:40:02Z","image":"https://ch0ser.github.io/images/greenland.png","permalink":"https://ch0ser.github.io/p/quick_fuzz/","title":"Quick_fuzz"},{"content":"DGF Overview\r定向灰盒测试相关技术 核心策略 时间顺序梳理 速览\nAFL(American Fuzzy Lop 2014)\r传统灰盒：全图覆盖，无定向\n变异策略\n确定性：bit/byte flip（翻转）、整数加减、边界值、字典 随机叠加（Havoc）：纯随机组合多种变异操作（如插入、删除、替换） 拼接（Splicing）：将两个种子拼接后执行 havoc 变异 反馈引导策略\n边覆盖率（Edge Coverage）：插桩追踪 CFG 边的命中情况，作为变异方向的反馈 上下文敏感边覆盖：区分同一 CFG 边在不同调用上下文下的命中情况，提升精度 路径覆盖（PathAFL）：记录完整路径哈希，避免路径碰撞 Ngram 插桩：记录最近前 N 个分支的历史状态 AFLGo （2017）\r首次提出“定向”概念，距离制导。（DGF 的起点）\nAFL（基于覆盖率引导）-\u0026gt;AFLGo（定向制导）\n距离度量（Distance Metric）\n静态阶段\n用 LLVM 生成调用图 CG + 过程间控制流图 ICFG。 对每个基本块到目标块跑 Dijkstra，算出最短路径长度 distance(b)。 一个种子到目标的距离取它所有覆盖块距离的 加权平均。 距离越小，优先级越高；距离为 0 表示已命中目标。 多目标扩展：若同时定向 N 个目标，可维护 最小距离 或 平均距离 两种模式（-m 选项）。\n能量调度（Power Schedule）\nAFLGo 把 AFL 的 perf_score 公式改造成 Simulated Annealing (SA) 形式，解决“过早收敛”与“局部最优”。\n1 2 3 double T = 1.0 / pow(20.0, progress_to_tx); // 温度随时间衰减 double p = (1.0 - normalized_d) * (1.0 - T) + 0.5*T; // 距离+时间双因子 perf_score *= pow(2.0, 2*log2(MAX_FACTOR)*(p-0.5)); 总结一下 模拟退火 ：早期系统鼓励探索，距离较远也给予能量（算力）；后期系统愈发挑剔，只给近距离种子变异机会。\n种子队列管理\n主队列（AFL ）：按覆盖率排队。 优先队列（AFLGo 新增）：按距离排序；每次 fuzz 80% 概率从优先队列取种子。 变异策略\n确定性阶段（固定套路） 与 AFL 相同（bit/byte flip, arith, interest, dictionary）。 距离度量不会缩短确定性阶段，只是 打分，保证兼容性。 Havoc / Splicing 距离越小的种子 获得的 havoc 轮次越多（由 power_factor 决定）。 对“已到达目标”的种子，AFLGo 会额外给 二次变异 机会，以探索目标附近的新分支（patch 回归测试常用）。 WindRanger（ICSE 2022）\r核心是用“走错路口”指路：Deviation Basic Block（DBB）。\nDBB 机制\n静态找“一步错即永远到不了目标”的块 动态过滤：仅保留种子真实触发者（它在执行时真的走错的路口） 距离\n仅累加 DBB 到目标的最短路径 × 难度系数（该系数青睐简单分支） 调度\nFavored 队列（90 %）：按 DBB 距离排序 Less-favored 队列（10 %）：保留全局探索 Beacon（IEEE S\u0026amp;P 2022）\r核心是 运行时剪枝：Weakest Precondition。\n核心\n静态：推导 最小充分条件 WP，插入 assert(WP) 动态：断言失败立即退出路径 代价\n复杂循环下 WP 爆炸，静态耗时显著 注意：与 DAFL 的“非侵入”不同，Beacon会 修改被测程序 本体。\n参考资料\rBöhme, M., Pham, V.-T., Nguyen, M.-D., and Roychoudhury, A. 2017. Directed Greybox Fuzzing. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security (CCS ’17). ACM, New York, NY, USA, 2329–2344. https://doi.org/10.1145/3133956.3134020 Du, Z., Li, Y., Liu, Y., and Mao, B. 2022. Windranger: A Directed Greybox Fuzzer Driven by Deviation Basic Blocks. In Proceedings of the 44th International Conference on Software Engineering (ICSE ’22). ACM, New York, NY, USA, 2440–2451. https://doi.org/10.1145/3510003.3510197 Huang, H., Guo, Y., Shi, Q., Yao, P., Wu, R., and Zhang, C. 2022. Beacon: Directed Grey-box Fuzzing with Provable Path Pruning. In Proceedings of the 2022 IEEE Symposium on Security and Privacy (SP ’22). IEEE, 36–50. https://doi.org/10.1109/SP46214.2022.9833709 Zalewski, M. 2018. American Fuzzy Lop (AFL). GitHub repository, https://github.com/google/AFL ","date":"2025-10-13T23:51:05Z","image":"https://ch0ser.github.io/images/EarlyMorningForest.png","permalink":"https://ch0ser.github.io/p/dgf-overview/","title":"DGF Overview"},{"content":"Docker命令\rDocker 镜像构建\rdocker build命令是 Docker 引擎的核心命令之一，用于根据 Dockerfile中的指令自动构建 Docker 镜像。\n核心概念与基础语法\r构建上下文：这是 docker build命令中指定的路径（通常是当前目录 .）。Docker 客户端会将这个路径下的所有文件（递归地）打包发送给 Docker 守护进程，因此只有上下文中的文件才能被 Dockerfile中的 COPY或 ADD指令使用。为了提高效率，建议使用空目录作为上下文，或通过 .dockerignore文件排除不必要的文件 Dockerfile：这是一个文本文件，包含了一系列用于构建镜像的指令（如 FROM, RUN, COPY等）。docker build会逐条执行这些指令，每条指令都会创建一个新的镜像层。 基本语法：\n1 docker build [OPTIONS] PATH | URL | - 其中 PATH就是构建上下文的路径。\n常用选项详解\r选项 说明与示例 适用场景 -t/ --tag 为构建出的镜像命名和打标签。格式为 name:tag。示例：docker build -t myapp:latest -t myapp:v1.0 . 镜像版本管理。 -f/ --file 指定要使用的 Dockerfile路径（当 Dockerfile不在上下文根目录或名称非默认时）。示例：docker build -f ./docker/Dockerfile.prod . 项目中有多个不同用途的 Dockerfile。 --build-arg 设置构建时的变量，这些变量可以在 Dockerfile中通过 ARG指令引用。示例：docker build --build-arg NODE_ENV=production . 动态传入构建参数，如版本号、环境变量。 --no-cache 强制忽略之前构建的缓存，执行全新构建。示例：docker build --no-cache . 确保依赖获取最新版本或解决缓存导致的构建问题。 --target 在多阶段构建的 Dockerfile中，只构建到指定的目标阶段。示例：docker build --target builder . 仅构建用于编译的中间阶段，以缩小最终镜像体积。 -q/ --quiet 安静模式，构建成功后只输出最终的镜像ID。 适用于自动化脚本，减少输出信息。 工作原理与流程\r发送上下文：Docker 客户端将整个构建上下文目录打包发送给 Docker 守护进程。因此，避免使用根目录 /作为上下文，以免发送大量无用数据。 逐行执行：守护进程逐条解析并执行 Dockerfile中的指令。 层缓存机制：每条指令都会生成一个只读的镜像层。Docker 会缓存未改变的层，后续构建时直接使用缓存，从而大幅加速构建过程。控制台输出中的 CACHED标识即表示使用了缓存。 输出镜像：所有指令执行完毕后，生成最终的镜像。 示例\r1 2 3 4 # -t 指定镜像名称，标签默认是latest # . 代表上下文默认为当前目录 # 所以要保证dockerfile以及里面要copy和add的文件在当前目录下 docker build -t gpac_cve-2019-20162 . Docker 容器启动\r启动Docker容器有多种方式，具体取决于使用场景和需求。以下是常见的启动容器方法及详细说明：\n基本启动命令\r使用docker run命令创建并启动一个新容器：\n1 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] /bin/bash 常用选项 -d：后台运行（守护态）。 -it：交互式终端（如/bin/bash）。 --name：指定容器名称。 -rm：容器停止后自动删除容器。 -p：端口映射（格式：主机端口:容器端口）。一般容器有通信需求会用 -v：挂载数据卷。 --restart：设置重启策略（如always、unless-stopped）。 /bin/bash：交互式终端进入工作目录。 示例：\n1 2 3 4 5 6 7 # 后台启动Nginx并映射端口 docker run -d --name my-nginx -p 8080:80 nginx # 挂载目录映射到容器内/testspace目录下 # 并且运行后会进入交互式终端（工作目录下） docker run -it --rm --name gpac_cve-2019-20162 \\ -v /mnt/d/A.S.E/benchmark-project/gpac:/testspace \\ gpac_cve-2020-23267 /bin/bash 启动已停止的容器\r若容器已存在但处于停止状态，使用docker start：\n1 docker start \u0026lt;容器ID或名称\u0026gt; 可结合-a参数查看输出日志。 进入运行中的容器\rdocker exec（推荐）：\n在运行中的容器内启动新终端，退出时容器不会停止：\n1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash docker attach： 直接进入容器的主进程终端，退出可能导致容器停止。\n使用Docker Compose启动多容器\r通过docker-compose.yml文件定义服务，一键启动：\n1 docker-compose up -d 适用场景：需编排多个关联容器（如Web+数据库）。 后台运行与资源限制\r后台运行：添加-d参数。 资源限制： 内存：-m 200M --memory-swap=300M。 CPU权重：--cpu-shares 512。 注意事项\r端口冲突：确保主机端口未被占用。 数据持久化：使用-v挂载重要数据，避免容器删除后丢失。 日志排查：启动失败时，通过docker logs \u0026lt;容器ID\u0026gt;查看错误。 Docker 容器/镜像重命名\r在Docker中，重命名容器可以通过以下命令和方法实现：\n使用docker rename命令\r这是最简便的方法，适用于运行中或已停止的容器：\n1 docker rename \u0026lt;旧容器名或ID\u0026gt; \u0026lt;新容器名\u0026gt; 示例：\n1 docker rename my_old_container my_new_container 注意：\n新名称必须唯一，不能与现有容器冲突。 操作不会影响容器内部进程或数据。 停止并重新创建容器\r若需保留原容器的配置，可先停止并删除原容器，再以新名称重新创建：\n1 2 3 docker stop old_container docker rm old_container docker run -d --name new_container [其他选项] \u0026lt;镜像名\u0026gt; 适用场景：需要调整其他参数（如端口、卷）时。 使用Docker Compose\r若容器由docker-compose.yml管理，直接修改文件中的服务名称并重启：\n1 2 3 services: new_name: # 修改此处 image: nginx 然后运行：\n1 docker-compose up -d 优势：适合多容器编排场景。 常见问题\r名称冲突：若新名称已存在，Docker会报错Conflict，需先删除或重名冲突容器。 验证结果：通过docker ps -a确认名称是否更新。 总结\n优先使用docker rename快速重命名；复杂需求（如配置变更）可结合停止重建或Compose调整。确保操作前后验证容器状态。\nDocker 容器提交为镜像\rdocker commit命令允许你直接将一个容器的当前状态（包括文件更改、已安装的软件、配置调整等）保存为一个新的 Docker 镜像。它就像给容器拍了一张快照，便于快速保存或分享特定工作状态。\n1 docker commit [OPTIONS] [容器名称] [镜像名称:tag] 选项 缩写 功能说明 示例 --author -a 指定新镜像的作者信息。 -a \u0026quot;张三 \u0026lt;zhang@example.com\u0026gt;\u0026quot; --message -m 添加提交信息，说明此次更改的内容。 -m \u0026quot;安装了Nginx服务器\u0026quot; --change -c 应用Dockerfile指令（如ENV, EXPOSE, CMD等）。 -c \u0026quot;EXPOSE 8080\u0026quot; --pause -p 提交时是否暂停容器以确保数据一致性（默认为true）。 --pause=false 适用情况：\n快速保存调试环境：当你在容器内进行复杂的配置或调试，并希望保存当前进度时，使用 docker commit可以快速创建一个镜像，下次可以直接从这一步开始，无需重头再来。 紧急热修复：生产环境中的容器出现问题需要立即修复时，你可以进入容器实施修复，然后通过 docker commit快速生成一个包含修复的临时镜像用于部署，为编写正式的 Dockerfile 争取时间。 创建自定义开发环境：基于一个标准镜像（如官方 Python 镜像）启动容器，安装团队所需的各种开发工具和依赖后，提交为一个标准的团队开发环境镜像，方便统一开发环境。 保存难以Dockerfile化的操作：有些交互式安装过程或图形界面软件的配置很难用 Dockerfile 指令完全自动化，这时可以通过交互操作后提交镜像来保存成果。 注意事项\n尽管 docker commit很方便，但也有一些重要的限制和需要注意的地方：\n可重复性差：通过 docker commit创建的镜像构建过程是黑盒的，缺乏像 Dockerfile 那样的声明性和可重复性。他人很难知晓镜像的准确构建步骤。所以在正式规范的团队开发里，还是尽量通过dockerfile来构建镜像。 容易导致镜像臃肿：交互式操作容易引入不必要的临时文件或缓存，如果未及时清理，会使镜像体积迅速膨胀。最佳实践：提交前，尽量清理缓存和临时文件（例如执行 apt-get clean）。 可能存在安全风险：无意中提交的镜像可能包含敏感信息，如密码、密钥等。最佳实践：提交前检查更改，使用 docker diff \u0026lt;容器名\u0026gt;查看文件系统差异，避免提交敏感数据。 不包含卷（Volume）中的数据：docker commit不会保存容器内挂载的卷中的数据。 最后一点补充说明一下，如果你想要保存容器内挂载的卷中的数据，可以用cp指令拷贝进容器内目录。\n1 2 cp [OPTIONS] [源目录] [目的目录] cp -r /testspace/gpac /workspace 前者为被复制的目录（或文件），后者为要复制到的目录 -r /-R：递归复制，用于复制目录和其中所有内容 -f：强制覆盖已存在的目标文件 -n：不覆盖已经存在的目录 Docker 打包镜像\rdocker save是一个非常有用的 Docker 命令，它能将你的 Docker 镜像打包成一个独立的归档文件（tar 格式），非常适合用于镜像的备份、迁移或在离线环境中分发。\n1 2 3 docker save -o [压缩包名称].tar [镜像名称]:[tag] docker save -o my_apps.tar app:v1.0 db:latest docker save redis:alpine \u0026gt; redis.tar -o：将指定标签的镜像保存为指定名称的 .tar文件 多个镜像打包：后面可以接好几个镜像一起打包 使用重定向：使用 Shell 重定向操作，效果与 -o相同 Docker 加载镜像\r1 2 3 docker load -i [压缩包名称].tar # 预计输出 Loaded image: [镜像名称]:[tag] 核心功能是：将 docker save导出的镜像包（如 nginx.tar）恢复至本地镜像库。\n加载过程会完整恢复镜像的所有层（Layers）、标签（Tag）、构建历史等元数据，保持镜像完整性。主要应用于离线环境部署、镜像备份恢复和批量镜像迁移。\n常见问题\n镜像标签为 \u0026lt;none\u0026gt;：有时加载后镜像名称和标签会显示为 \u0026lt;none\u0026gt;。这通常是因为 tar 文件本身未包含标签信息\n。解决方法很简单，使用 docker tag命令手动为其打上标签即可：\n1 2 3 4 5 # 先通过 docker images 查看镜像ID docker images # 然后为指定镜像ID打上标签 docker tag \u0026lt;镜像ID\u0026gt; nginx:latest [1,6](@ref) 加载失败排查：如果加载失败，可以先检查 tar 文件是否完整。可以使用 tar -tf nginx.tar命令查看压缩包内容列表。另外，也要确保 Docker 宿主机有足够的磁盘空间。\nDocker 镜像推送\r推送镜像是将你本地构建好的镜像上传到远程仓库（一般是dockerhub官网），以便他人或其他机器使用。\n登录仓库\n首先需要使用 docker login命令登录到目标镜像仓库（如 Docker Hub 或你的私有仓库）。\n1 2 3 docker login # 或者指定私有仓库地址 docker login myregistry.example.com 执行后会提示输入用户名和密码。如果使用私有仓库，地址需替换为你的仓库地址。\n标记镜像\n在推送之前，必须为本地镜像打上一个符合远程仓库命名规范的标签，格式通常为 [仓库地址]/[用户名或项目名]/[镜像名]:[标签]。当然如果本来就是规范命名就不用改。使用 docker tag命令：\n1 2 3 4 # 语法：docker tag 本地镜像名:标签 新标签 docker tag my-app:latest yourusername/my-app:v1.0 # 如果推送到私有仓库，地址可能如下 docker tag my-app:latest myregistry.example.com/yourproject/my-app:prod 执行推送\n使用 docker push命令将标记好的镜像推送到远程仓库。\n1 docker push yourusername/my-app:v1.0 推送成功后，就可以在远程仓库的页面上看到这个镜像了。\nDocker 拉取镜像\r拉取镜像是从远程仓库将镜像下载到本地环境的过程。\n基本拉取命令\n最基础的命令是 docker pull，后面跟上镜像的名称和标签（可选，默认为 latest）。\n1 2 3 4 5 6 # 拉取官方Nginx镜像的最新版本 docker pull nginx # 拉取指定标签的镜像 docker pull nginx:1.27.0-perl # 从私有仓库拉取 docker pull myregistry.example.com/yourproject/my-app:prod 验证拉取结果\n拉取完成后，使用 docker images命令可以查看本地已下载的镜像列表，确认镜像是否成功拉取。\nDocker镜像拉取失败解决方案\r如果docker镜像拉取失败，且报错为连接超时，无法连接，可以采取以下办法。\n1.排查DNS\n1 sudo nano /etc/resolv.conf 如果resolv.conf中没有8.8.8.8和8.8.4.4，就添上。\n1 2 nameserver 8.8.8.8 nameserver 8.8.4.4 改完后，ctrl+o保存，再enter确认，最后ctrl+x退出。\n此修改在系统重启时会重置，其实也可以永久修改，但是比较麻烦，要拉取的时候修改即可。\n2.修改拉取源\n1 sudo nano /etc/docker/daemon.json 添加国内镜像站：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://dockerproxy.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://docker.nju.edu.cn\u0026#34;, \u0026#34;https://iju9kaj2.mirror.aliyuncs.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://cr.console.aliyun.com\u0026#34;, \u0026#34;https://hub.docker.com\u0026#34;, \u0026#34;http://mirrors.ustc.edu.cn\u0026#34; ] } 改完后，ctrl+o保存，再enter确认，最后ctrl+x退出。\n3.重启docker服务\n1 2 3 4 # 重新load daemon.json sudo systemctl daemon-reload # 重启docker服务 sudo systemctl restart docker 这个时候再试试拉取，多半成功了。\n","date":"2025-10-06T21:56:04Z","image":"https://ch0ser.github.io/images/TrippyWave.png","permalink":"https://ch0ser.github.io/p/docker-commands/","title":"Docker Commands"},{"content":"Git使用教程\r安装\r官网下载安装即可，安装配置基本默认。\nhttps://git-scm.com\n常用命令\r命令 描述 git config --global user.name 用户名 设置用户签名 git config --global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m \u0026quot;日志信息\u0026quot; 文件名 提交到本地库 git reflog / git log 查看历史记录 git reset --hard 版本号 版本穿梭 基本操作\r设置用户签名\r1 2 git config --global user.name user_name git config --global user.email user_email git config --global 命令的作用范围是针对 该设备上所有 Git 仓库 的全局配置。\n所以只要配置一次就好了。\n要查看当前的 Git 全局配置，可以使用以下命令：\n1 git config --global --list 查看特定配置项\n如果你只想查看某个特定的全局配置项，可以使用以下命令：\n1 git config --global [配置项名称] 例如：\n1 git config --global user.name 这将只显示全局配置中的用户名。\n初始化本地库\r1 git init 在对应项目文件夹目录下创建Git仓库。\n查看本地状态\r1 git status git status 命令用于显示当前 Git 仓库的状态。它会告诉你哪些文件被修改了、哪些文件被添加到暂存区（staging area）、哪些文件未被跟踪等信息。\n以下是 git status 可能显示的一些关键信息：\n当前分支： 显示你当前所在的分支名称。 本地更改： 未跟踪的文件：显示仓库中尚未添加到暂存区的新文件。 修改过的文件：显示自上次提交以来已被修改的文件。 暂存区更改： 已暂存的更改：显示已被添加到暂存区的文件，这些更改将在下一次提交时被包含。 已暂存但修改过的文件：显示已暂存但自暂存后又被修改的文件。 冲突： 如果你在合并或拉取时遇到冲突，git status 会显示这些冲突文件，提示你需要手动解决这些冲突。 分支状态： 如果你的分支与远程分支有差异，git status 会显示这些差异，例如本地分支领先、落后或与远程分支同步。 未暂存的更改： 显示自上次提交以来未被添加到暂存区的文件更改。 提示信息： 根据当前状态，git status 可能会提供一些有用的提示信息，例如如何添加文件到暂存区或如何提交更改。 添加到暂存区\r1 git add 文件名 git add 是一个 Git 命令，用于将更改添加到暂存区（staging area），这是提交（commit）更改到本地仓库之前的一个必备步骤。它允许你精确控制哪些更改应该包含在下一次提交中。\n暂存区是一个文件，保存了下次将提交到本地仓库的更改列表。\n添加单个文件：\n1 git add \u0026lt;文件名\u0026gt; 这会将指定文件的更改添加到暂存区。\n添加多个文件：\n1 git add \u0026lt;文件1\u0026gt; \u0026lt;文件2\u0026gt; ... 你可以一次性添加多个文件到暂存区。\n添加所有更改：\n1 git add . 或者\n1 git add -A 这会将所有新的、修改的和删除的文件（不包括未跟踪的文件）添加到暂存区。\n提交到本地库\rgit commit 用于将暂存区（staging area）的更改提交（commit）到本地仓库。提交是版本控制中保存项目历史记录的基本单元。\n1 git commit -m \u0026#34;提交信息\u0026#34; 这将提交暂存区的更改，并使用提供的提交信息。-m 选项允许你在命令行中直接添加提交信息，而不需要打开文本编辑器。\n查看历史记录\rgit reflog 和 git log 都是 Git 中用于查看项目历史记录的命令，但它们的用途和显示的信息有所不同。\ngit reflog\ngit reflog 命令显示了所有引用（包括分支和标签）的更新历史。它记录了HEAD和分支引用的每一次移动，无论这些移动是否由提交引起。\ngit reflog 可以显示由于各种操作（如提交、回退、创建分支、切换分支等）引起的引用变化。\n1 git reflog 这将显示一个按时间排序的列表，列出了HEAD和分支引用的每一次更新。\ngit log\ngit log 命令显示了提交历史，包括每次提交的作者、日期、提交信息等详细信息。它主要用于查看项目的提交历史。\n1 git log 这将显示项目的提交历史，包括每次提交的哈希值、作者、日期和提交信息。并且git log还支持多种格式：可以通过选项自定义输出格式，如简洁格式、一行列格式等，并且支持过滤：可以通过选项过滤特定的提交，如按作者、日期、路径等过滤。\n常用选项\n--oneline：以一行列格式显示提交信息，只显示哈希值和提交信息。\n查看简洁的提交历史：\n1 git log --oneline --graph：显示分支合并图。\n查看带有分支合并图的提交历史：\n1 git log --graph --oneline --since 和 --until：按时间过滤提交。\n--author：按作者过滤提交。\n--grep：搜索提交信息中的关键词。\n搜索特定作者的提交：\n1 git log --author=\u0026#34;用户名\u0026#34; 查看特定时间段内的提交：\n1 git log --since=\u0026#34;2024-01-01\u0026#34; --until=\u0026#34;2024-12-31\u0026#34; 版本穿梭\r1 git reset --hard 版本号 上述命令用于将当前分支和工作目录重置到指定的版本号，即某个特定的提交（commit）。这个命令会改变当前分支的 HEAD 指针，并且会重置工作目录和暂存区，使其与指定的提交完全一致。注意，这意味着所有在该提交之后所做的更改都将丢失，包括未提交的更改和暂存的更改，这是不可逆的。\n你需要找到你想要回退到的版本号，可以通过 git log 命令查看提交历史，找到对应的提交哈希值。\n分支操作\r分支的好处\n同时并进行多个功能开发，提高了开发效率 各个分支再开发过程中，如果某个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可 分支常用命令\r命令 描述 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 需要合并的分支名 把指定的分支合并到当前分支上 查看分支\r1 2 git branch -v git branch git branch -v 命令用于列出 Git 仓库中的所有分支，并显示每个分支的最新提交信息。这个命令是 git branch 命令的一个变体，其中的 -v 选项代表“verbose”，即详细模式。\n创建分支\r1 git branch 分支名 git branch 分支名 是一个用于创建新分支的 Git 命令。当你想要从当前开发线（通常是主分支）创建一个新的开发线时，这个命令非常有用。\n这将在当前 HEAD 指向的提交处创建一个新分支，但不会自动切换到该分支。\n切换分支\r1 git checkpoint 分支名 这将切换到指定的分支，并更新工作目录以反映该分支的状态。\n合并分支\r1 git merge 需要合并的分支名 //把指定的分支合并到当前分支上 git merge 用于将一个分支的更改合并到当前分支。这通常用于合并功能分支到主分支（如 main 或 master），或者合并修复分支到开发分支。\n合并过程中的冲突\n在合并过程中，如果存在冲突（即两个分支对同一文件的同一部分进行了不同的更改），Git 会停止合并并让你手动解决这些冲突。你需要：\n手动解决冲突：打开冲突的文件，手动编辑以解决冲突。 标记冲突已解决：使用 git add 命令将解决冲突后的文件标记为已解决。 完成合并：使用 git commit 命令完成合并。 远程仓库的操作\r添加远程库地址\r1 git remote add origin 远程库地址 git remote add origin 远程库地址 用于将远程仓库添加到你的本地 Git 仓库中。当你创建一个新的本地仓库并希望将其与远程仓库（如 Gitee、GitHub、GitLab 等）关联时，这个命令非常有用。\n命令解释\ngit remote：这是用于管理远程仓库引用的命令。 add：这个子命令用于添加一个新的远程仓库引用。 origin：这是远程仓库的默认短名称。Git 使用 origin 作为远程仓库的默认名称，但你也可以使用其他名称。 远程库地址：这是远程仓库的 URL 地址。 验证远程仓库\n添加远程仓库后，你可以使用以下命令来查看所有远程仓库的 URL：\n1 git remote -v 这将列出所有远程仓库的名称和对应的 URL。\n修改远程仓库 URL\n如果你需要修改远程仓库的 URL（例如，从 HTTPS 更改为 SSH），你可以使用以下命令：\n1 git remote set-url origin 新的远程库地址 将 新的远程库地址 替换为你新的远程仓库 URL。\n删除远程仓库\n如果你不再需要某个远程仓库，你可以使用以下命令删除它：\n1 git remote remove origin 这将删除名为 origin 的远程仓库引用。\n拉取远程库文件\r1 git pull origin master 这个命令会从远程仓库的 master 分支拉取最新的更改，并尝试将这些更改合并到你当前所在的本地分支。(有时是用main分支)\n简言之就是从远程库拉取文件到工作区。\n上传远程库文件\r1 git add . //将所有改变添加到暂存区 上传前要执行git add 将更改添加到暂存区（staging area）。\n1 git commit -m \u0026#34;message\u0026#34; 再执行git commit 将暂存区（staging area）的更改提交（commit）到本地仓库。\n1 git push origin (master/分支的名字) 最后执行git push将本地库文件上传到远程库。\n1 git push -u origin 分支名 这条命令做了两件事：\n推送分支：将您的本地分支推送到远程仓库 origin。 设置上游分支：-u 参数将远程分支设置为本地分支的上游分支，这样您以后可以直接使用 git push 或 git pull 命令而不需要指定远程仓库和分支名。 ","date":"2025-02-21T20:58:54Z","image":"https://ch0ser.github.io/images/PacificRim_02.PNG","permalink":"https://ch0ser.github.io/p/quick-git/","title":"Quick Git"},{"content":"1 Java背景知识\r1.1 JDK JRE JVM\rJDK(开发工具包) JRE(运行环境)运行时类库 JVM(Java虚拟机) JDK:（Java Development Kit）\nJava标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。\nJRE:（Java Runtime Environment）\nJava运行环境，用于解释执行Java的字节码文件。\nJVM: (Java Virtual Machine)\nJava虚拟机，是JRE的一部分，负责解释执行字节码文件，是可运行Java字节码文件的虚拟计算机。\n区别联系：（问答题会考可能）\nJDK包含JRE，JDK和JRE中都包含JVM。JDK除了包含JRE还包含一些常用开发工具和基础类库。\nJDK用于开发，JRE用于运行Java程序。\nJVM是Java编程语言的核心并且具有平台独立性。\n1.2 开发Java程序需要的3个步骤：\r编写源文件 编译源文件生成字节码 加载运行字节码 1.3 Java程序运行过程:\r1 javac:\tjava源文件-\u0026gt;class字节码文件(0,1) 2 java: 运行class文件\n1.4 java程序语句执行的顺序\rjava程序语句执行的顺序包括4种基本控制结构：顺序结构、选择结构、循环结构、异常处理逻辑结构。 如果三个空（那就顺序 选择 循环）\n2 编程基础\r2.1 Java的基本语法\r\u0026ndash;方法格式\r1 2 3 4 权限修饰符 返回值声明 方法名称(参数列表){ 方法中封装的逻辑功能; return 返回值; } \u0026ndash;权限修饰符\r下表为Java访问控制符的含义和使用情况\n访问级别 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × default也叫友好型\n\u0026ndash;注释\r// 单行注释 /* 多行注释 /\t/* 文档注释 */\n\u0026ndash;关键字\r关键字 含义 private 私有的 protected 受保护的 public 公共的 abstract 声明抽象 class 类 extends 继承、扩展 final 最终、不可改变 implements 实现 interface 接口 native 本地 new 新，创建 static 静态 strictfp 严格，精准 synchronized 线程、同步 transient 短暂 volatile 易失 程序控制语句 含义 break 跳出，中断 continue 继续 return 返回 do 运行 while 循环 if 如果 else 否则 for 循环 其它关键字 含义 instanceof 实例 switch 观察 case 返回观察里的结果 default 默认 try 捕获异常 catch 处理异常 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 import 引入 package 包 boolean 布尔型 byte 字节型 char 字符型 double 双精度 float 浮点 int 整型 long 长整型 short 短整型 null 空 TRUE 真 FALSE 假 super 父类，超类 this 本类 void 无返回值 goto 跳转 const 静态 native 本地 \u0026ndash;标识符\r(你自己定义的一个东西的名字(比如类名，方法名，变量名，接口名，常量名\u0026hellip;))\n\u0026ndash;注意事项定义的时候:\n示识符:\n由字母、数字、下划线(_)和美元符号($)组成。\n不能以数字开头。\n不能是Java中的关键字。\n2.2 变量 常量\r\u0026ndash;变量的定义\r按所属的数据类型划分：\n基本数据类型变量 引用数据类型变量 按被声明的位置划分：\n局部变量：方法或语句块内部定义的变量\n成员变量：方法外部、类的内部定义的变量\n基本数据类型\n类型 名称 含义 bit 字节数 值范围 整型 byte 字节 8 1字节 -128 到 127 整型 short 短整型 16 2字节 -32768 到 32767 整型 int 整型 32 4字节 -2,147,483,648 到 2,147,483,647 整型 long 长整型 64 8字节 -9223372036854775808 到 922337203685477580 浮点型 float 浮点数 32 4字节 有效位数15位 浮点型 double 双精度浮点数 64 8字节 有效位数15位 字符 char 字符 16 2字节 Unicode字符集 布尔型 boolean 布尔型 1 true/false 布尔型（boolean）的字节数在Java中并不是精确定义的，它是一个特殊的类型，用于表示真（true）或假（false）。在Java虚拟机（JVM）中，boolean的存储可能与其他基本类型不同，且其大小可能依赖于JVM的实现。在实际应用中，boolean通常用于逻辑判断，而不是进行数值计算。\n引用数据类型\n在 Java 中，引用类型（Reference Types）是指那些不是基本数据类型（如 int、char、double 等）的类型。引用类型包括以下几种：\n类（Class）：用户自定义的类，例如 public class A {...} 中的 A 类。\n接口（Interface）：定义了一组方法规范，但不提供实现的类型。\n数组（Array）：存储固定大小的相同类型元素的集合，例如 int[] numbers = new int[10];。\n枚举（Enum）：一种特殊的类类型，其值是固定的常量，例如 enum Day { MONDAY, TUESDAY, WEDNESDAY, ... };。\n注解（Annotation）：一种特殊的接口类型，用于提供元数据，例如 @Deprecated。\n字符串（String）：虽然 String 在 Java 中是不可变的，但它是一个引用类型，用于表示字符序列。\n\u0026ndash;变量的类型转换\rboolean 类型不能转换成任何其它数据类型。\n自动类型转换\n容量小的类型自动转换成容量大的数据类型 byte, short, int -\u0026gt; float -\u0026gt; long -\u0026gt; double byte, short, int 不会互相转换，它们三者在计算时会转换成 int 类型\n显式类型转换\n容量大的类型转换成容量小的数据类型时，要加上强制转换符(截断转换)\n1 2 float b = 3.0f a = (int)b \u0026ndash;变量的作用域\r成员变量(全局变量 private int i=0;)或静态变量 private static String name=\u0026ldquo;list\u0026rdquo;) 在类体内定义的变量称为成员变量，它们作用域是整个类 局部变量 在一个方法或方法内代码块中定义的变量称为局部变量 \u0026ndash;Java中的常量\r(不怎么考)\n常量不能被转换，例如常数\n\u0026ndash;注意事项\r1 2 3 4 变量定义注意事项： float a=13.3f 带上\u0026#39;f\u0026#39; long a=222222222222L 带上\u0026#39;L\u0026#39; char c= \u0026#39;A\u0026#39; 带上\u0026#39; \u0026#39; 2.3 运算符\r算数\r1 2 + - * / % ++ -- / 取商 ；% 取余 赋值\r=\n关系\r\u0026lt; \u0026gt;= \u0026lt;= == !=\n逻辑\r! \u0026amp;\u0026amp; ||\n\u0026amp; |\t不怎么用\n^ 按位异或运算符,逻辑异或运算符\n位运算符(不会考)\n~ \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\n条件运算符\rcondition ? valueIfTrue : valueIfFalse;\ncondition：一个布尔表达式，其结果为 true 或 false。 valueIfTrue：如果 condition 为 true，则这个值会被选择。 valueIfFalse：如果 condition 为 false，则这个值会被选择。 1 2 int score = 85; String grade = score \u0026gt;= 90 ? \u0026#34;A\u0026#34; : \u0026#34;B\u0026#34;; 在这个例子中，如果 score 大于或等于90，grade 将被赋值为 \u0026quot;A\u0026quot;；否则，它将被赋值为 \u0026quot;B\u0026quot;。\n2.4.1 选择语句\r1 2 3 4 5 6 7 8 9 10 11 if else if\t(接在if后面，多重选择) else 这三个与c语言基本相同 switch(XX) { //java特有 枚举 short byte int char String //C语言:字符,int case 1: XX;break; case 2: XX;break; default(可有可无): XX break; } 2.4.2 java的循环\r1 2 3 4 while(){} for(){} do{} while() 以上三种和c语言基本一样 1 2 3 for (ElementType element : collection) { // 在这里处理集合中的每个元素 } ElementType：表示集合中元素的数据类型。 element：表示当前遍历到的集合元素的变量。 collection：表示要遍历的数组或集合。 1 2 3 4 5 6 7 8 9 int[] numbers = {1, 2, 3, 4, 5}; for (int number : numbers) { System.out.println(number); } List\u0026lt;String\u0026gt; words = Arrays.asList(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;Java\u0026#34;); for (String word : words) { System.out.println(word); } 2.5 数组\r-不允许在前面的括号写元素个数\n2.5.1 多维数组初始化3种方式\r\u0026ndash;动态两种\njava的多维数组每一维数可不同\n1 2 3 4 5 1 int[][] arr = new int[3][]; //指定了行数，未指定列数 arr[0] = new int[3];//第0行3列 arr[1] = new int[2];//第1行2列 arr[2] = new int[1];//第2行1列 1 2 3 2 int[][] arr2 = new int[3][2];//同时指定行数和列数 arr[0][0] = 33;//单独对元素赋值 \u0026ndash;静态一种\n1 2 int arr4[][] = new int[][]{{1, 2, 3}, {2, 3}}; //第0行是{1，2，3}，第1行是{2，3} 不赋值默认元素为0\n一般来说初始化时都默认括号在数组名前，这是Java的风格，当然反过来也一样可行（c语言风格）\n2.5.2 数组的常见操作\r声明数组：\n1 int arr[] 数组初始化：\n1 2 int[] arr={1,2,3,4}; int[] arr=new int[]{1,2,3,4}; 查看数组长度：\n1 2 arr.length; 返回值是整数，反映了数组中第一维元素的个数 for each 循环：\n1 2 3 for(int a:arr){ System.out.println(a); } 数组拷贝：\n1 2 3 4 int[] arr2=arr1; 或 int[] arr2=Arrays.copyOf(arr, arr.length(自定义长度)); arr2会复制arr1 length长度的元素 数组排序：\n1 2 Arrays.sort(arr); 默认从小到大排序 将int数组转换为字符串：\n1 2 Arrays.toString(arr); 连括号一起转换成字符串了 2.6 输入输出\r输入\r1 2 Scanner s = new Scanner(System.in); //先创建了一个Scanner对象s，用于从System.in（标准输入流，即键盘输入）读取数据。 在Java中，Scanner 类的 next() 方法用于从输入流中读取下一个完整的 token。Token 通常是输入中的一个单词，由空白字符（如空格、制表符或换行符）分隔。next() 方法会读取并返回一个字符串，直到遇到下一个空白字符，但不包括这个空白字符。（类比scanf）\n1 2 3 4 String word = s.next(); // 从标准输入读取一个单词 System.out.println(\u0026#34;输入的单词是: \u0026#34; + word); //输出 如果需要读取包含空格的字符串，应该使用 nextLine() 而不是 next()。\n它将读取输入直到遇到换行符（\\n），并将换行符之前的所有内容（包括空格）作为字符串返回。\n1 String sentence = s.nextLine(); // 读取整行，包括空格 在s.next()的基础上，有：\n1 2 3 4 5 6 s.nextInt(); //读取用户输入的下一个整数 s.nextFloat(); //读取用户输入的下一个浮点数。这可以是单个数字、小数或科学记数法表示的数字 //即： s.next类型名(); Scanner 类的 hasNext() 方法用于检查输入流中是否还有更多的输入。这是一个非常有用的功能，尤其是在处理不确定数量的输入时，比如在读取用户输入直到用户决定停止时。\n1 2 3 4 5 6 7 8 Scanner s = new Scanner(System.in); while (s.hasNext()) { String input = s.next(); if (\u0026#34;end\u0026#34;.equals(input)) { break; // 结束循环 } System.out.println(\u0026#34;处理输入: \u0026#34; + input); } 同理有：hasNextLine() hasNextFloat()等方法检验有无特定类型的输入\n这里插入一下字符串的比较，equals()方法\n1 2 3 4 5 boolean areEqual = str1.equals(str2); //若str1与str2内容相同，返回true，反之返回false //注意：空值检查 //如果 equals 方法的参数是 null，那么在没有进行空值检查的情况下直接调用会导致 NullPointerException。 //因此，通常在调用 equals 方法之前，会先检查参数是否为 null。 输出\r在Java中，输出数据到控制台或文件可以通过多种方式实现。以下是一些输出方法：\nSystem.out.print 和 System.out.println：（常用）\nSystem.out.print：将数据打印到标准输出（通常是控制台），但不换行。 System.out.println：将数据打印到标准输出，并在末尾添加一个换行符。 1 2 System.out.print(\u0026#34;Hello, \u0026#34;); System.out.println(\u0026#34;World!\u0026#34;); System.out.printf：\n用于格式化输出，类似于C语言中的 printf 函数。可以指定输出格式和宽度等。 1 System.out.printf(\u0026#34;The value of pi is: %.2f%n\u0026#34;, Math.PI); System.out.format：\n类似于 System.out.printf，但返回 String 对象而不是打印到控制台。 1 String formattedString = System.out.format(\u0026#34;The value of pi is: %.2f%n\u0026#34;, Math.PI); PrintStream：\nSystem.out 是一个 PrintStream 对象，提供了更多的方法来控制输出，如 print, println, printf, format 等。 BufferedWriter：\n用于将文本写入字符输出流，可以提高写入性能，特别是当写入大量数据时。 1 2 3 4 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out)); writer.write(\u0026#34;Hello, World!\u0026#34;); writer.newLine(); // 写入换行符 writer.flush(); // 清空缓冲区 PrintWriter：\n用于打印格式化表示的字符到控制台或文件。 1 2 3 PrintWriter writer = new PrintWriter(System.out, true); writer.println(\u0026#34;Hello, World!\u0026#34;); writer.flush(); // 清空缓冲区 FileWriter：\n用于写入字符到文件。 1 2 3 FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;); writer.write(\u0026#34;Hello, World!\u0026#34;); writer.close(); // 关闭文件写入器 Files.write (Java 7+)：\n用于将字节数据写入文件，可以指定字符编码。 1 2 Path path = Paths.get(\u0026#34;output.txt\u0026#34;); Files.write(path, \u0026#34;Hello, World!\u0026#34;.getBytes(StandardCharsets.UTF_8)); Logger：\nJava的日志记录框架，用于记录应用程序的日志信息。 1 2 Logger logger = Logger.getLogger(\u0026#34;MyLogger\u0026#34;); logger.info(\u0026#34;Hello, World!\u0026#34;); StringBuffer 和 StringBuilder：\n用于在内存中构建字符串，特别是当需要多次修改字符串内容时。 1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello, \u0026#34;); sb.append(\u0026#34;World!\u0026#34;); System.out.println(sb.toString()); 选择哪种输出方法取决于你的具体需求，比如是否需要格式化输出、是否需要写入文件、是否需要考虑性能等因素。\n2.7.1 类与对象\r概念 三大特征 封装 “通过 private、default、protected、public 关键字实现属性或方法的封装，仅对外提供公共访问方式。” “高内聚、低耦合”\n封装的好处：\n实现数据和方法的隐藏 实现信息隐藏，允许外部对类有限的访问，开发者可以自由的改变类的内部实现 提高了代码的重用性 继承\n通过 extends。 两个好处：\n代码重用了。 通过继承，实现对现实世界更加准确的建模。 多态\n多态是指允许不同类的对象对同一消息做出响应，即同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果。在Java中多态的实现方式：接口实现，继承父类进行方法重写。同一个类中进行方法重载，父类引用指向子类对象。\n2.7.2 类与对象 (重点)\r关系\n实例化(对象的创建)\n通过 new 关键字创建 比如\n1 2 Student zhangchunhui = new Student(); zhangchunhui.setAge(20); 1 2 3 4 5 6 class Student{ private int age; public static void setAge(int age){ this.age = age; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Stu{ //1 属性设为私有 private int age; //2 方法 get set 你自己定义的 public void setAge(int age) { this.age = age; } public int getAge() { return this.age; } //我自己定义的方法 public void myPrint() { System.out.println(\u0026#34;nihao\u0026#34;); } //3 构造函数 public Stu() { } 或 public Stu(int age) { this.age = age; //类内用this指代该类 } } 若使用无参数构造函数\n1 2 Stu student1 = new Stu(); // 创建了一个Stu对象，但是age属性没有被初始化 student1.setAge(25); // 之后可以手动设置age属性的值 若使用带参数构造函数\n1 Stu student2 = new Stu(20); // 创建了一个Stu对象，并且age属性被初始化为20 类的定义(格式,注意事项)\n1 2 3 4 [修饰符] class 类名 [extends 父类名] [implements 接口名]{ // 类体，包括类的成员变量和成员方法 } //[]表示可选 2.8 类的继承\rObject类\nObject类是所有类的父类，里面有很多方法 clone getClass toString equals hashCode notify notifyAll wait finalize\ngetClass方法 获取运行时类型，返回值为Class对象 hashCode方法 返回该对象的哈希码值，是为了提高哈希表的效率（Hashtable） equals方法 判断两个对象是否相等，在Object类中equals就是使用==去判断，所以在Object的子类中，如果equals相等的两个对象，hashCode一定相等，实现不同的比较。 clone方法 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递。我们有时候不希望在方法里修改参数，这就需要在类中重写clone方法。 如果在clone方法中调用super.clone()方法需要实现Cloneable接口，否则会抛出CloneNotSupportedException。 此方法只实现了一个浅层拷贝，对于基本类型字段成功拷贝，但是如果是数组等对象，只做了浅拷贝，也就是只复制了对象的引用，所以需要自己重写clone方法进行深层拷贝。 toString方法 返回一个String字符串，用于描述当前对象的信息，可以重写该方法返回对自己有用的信息，默认返回的是当前对象的类名+hashCode的16进制数字。 wait方法 多线程中用到的方法，作用是让当前线程进入等待状态，同时也会释放当前线程所持有的锁。直到其他线程调用此对象的notify()方法或notifyAll()方法，当前线程才会被唤醒。 notify方法 多线程时用到的方法，唤醒该对象等待的某个线程 notifyAll方法 多线程时用到的方法，唤醒该对象等待的所有线程 finalize 对象在被垃圾收集器回收前一定会调用finalize方法，对象被释放前最后的挣扎，因为无法确定该方法什么时候被调用，很少使用。 \u0026ndash;类的继承格式\n1 2 3 4 5 class 父类 { } class 子类 extends 父类 { } \u0026ndash;继承了之后有父类(非私有private)的属性或方法,可直接调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Animal { public String name; private int id; public Animal(String myName, String myId) { // 初始化属性值 } public void eat() { } public void sleep() { System.out.println(\u0026#34;晚上了我要睡觉\u0026#34;) } } public class Owl extends Animal{ } \u0026mdash;重写父类方法\n子类可以重写父类的同名方法，以根据需求覆盖原方法\n1 2 3 4 5 public class Penguin extends Animal{ public void sleep() { System.out.println(\u0026#34;白天了我要睡觉\u0026#34;) } } 2.9 类的封装\r将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供getter/setter的方法来对隐藏的信息进行操作和访问。\ngetter setter\n封装的实现步骤：\n(1) 将成员属性的可见性设为（private）\n(2) 创建getter/setter方法（用于属性的读写）（通过这两种方法对数据进行获取和设定，对象通过调用这两种方法实现对数据的读写）\n(3) 在getter/setter方法中加入属性控制语句（对属性值的合法性进行判断）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Person { private String name; private int age; public int getAge() { return age; } public String getName() { return name; } public void setAge(int age) { if(age \u0026lt; 0){ System.out.println(\u0026#34;你的年龄不合法请重新输入\u0026#34;)； } else{ this.age = age; } } public void setName(String name) { this.name = name; } } //通过方法来访问或者修改私有private的属性 2.10 构造方法(重点)\r\u0026ndash;定义\n主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。\n\u0026ndash;重载\n1 2 3 4 5 6 7 8 9 10 11 12 public Animal2(String name, int myid) { this.name = name; this.id = myid; } public Animal2(String name) { this.name = name; } public Animal2(int id2) { this.id = id2; } 2.11 方法的重载 和 重写\r\u0026ndash;回顾一下方法定义格式：\n1 2 3 4 权限修饰符 返回值声明 方法名称(参数列表){ 方法中封装的逻辑功能; return 返回值; } 重载（Overloading）：\n发生在同一个类中，当多个方法有相同的名称但参数列表不同（与返回值类型、修饰符无关）时，这些方法就是重载的。\n重载的目的是为了提供相同功能但使用不同参数的方法，以提高代码的可读性和灵活性。\n示例见下或2.10\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Calculator { // 重载方法1：两个整数相加 public int add(int a, int b) { return a + b; } // 重载方法2：三个整数相加 public int add(int a, int b, int c) { return a + b + c; } // 重载方法3：两个浮点数相加 public double add(double a, double b) { return a + b; } } 重写（Overriding）：\n发生在子类和父类之间，当子类有一个与父类方法签名（方法名称和参数列表）完全相同的方法时，子类的方法就重写了父类的方法。\n重写的目的是为了提供特定于子类的行为，即子类可以根据自己的需要改变父类方法的行为。\n实例见 2.8\n重写的注意事项：\n重写的方法必须要和父类一模一样（包括返回值类型、方法名、参数列表）。 重写的方法可以使用 @Override 注解来标识。 子类中重写的方法的访问权限不能低于父类中方法的访问权限。权限修饰符的顺序是：private \u0026lt; 默认（什么都不写） \u0026lt; protected \u0026lt; public。 2.12.1 this 关键字\rJava 中为解决变量的命名冲突和不确定性问题，引入关键字 this 代表其所在方法的当前对象的引用：\n构造方法中指该构造器所创建的新对象: 1 2 3 4 5 6 7 8 public class B { A a; // A是另一个类，算一个类型 // 构造方法，接收一个 A 类型的参数 public B(A a) { this.a = a; // 使用 this 来区分成员变量 a 和参数 a } } 方法中指调用该方法的对象: 1 2 3 4 5 6 7 8 9 10 public class Baby { public void wakeUp() { System.out.println(\u0026#34;宝宝醒啦\u0026#34;); } public void eat() { this.wakeUp(); // 调用当前对象的wakeUp方法 System.out.println(\u0026#34;吃东西\u0026#34;); } } 在类本身的方法或构造器中引用该类的实例变量（全局变量）和方法: 1 2 3 4 5 public void setName(String name) { this.name = name; // 使用this关键字来区分成员变量和方法参数 //this.name是成员变量，name是方法参数 } \u0026ndash;注意\nthis 只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现 this\n\u0026ndash;原因：static 方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。\n2.12.2 super 关键字\r一句话概括：super 关键字主要存在于子类方法中，用于指向子类对象中的父类对象；可以访问父类的属性、函数以及构造函数。\n当子类和父类存在着同名的成员（包括变量和方法）时，在子类中默认是访问子类的成员，可以通过 super 关键字指定访问父类的成员。\n默认会先调用父类无参的构造方法，可以通过 super 关键字指定调用父类的构造方法。\n示例\n假设我们有一个父类 Animal 和一个子类 Dog，我们可以这样使用 super 关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Animal { String name; // 父类的构造方法 public Animal() { System.out.println(\u0026#34;Animal\u0026#39;s constructor\u0026#34;); } // 父类的方法 public void makeSound() { System.out.println(\u0026#34;Some generic animal sound\u0026#34;); } } class Dog extends Animal { // 子类的构造方法 public Dog() { super(); // 调用父类的无参构造方法 System.out.println(\u0026#34;Dog\u0026#39;s constructor\u0026#34;); } // 子类重写的方法 @Override public void makeSound() { System.out.println(\u0026#34;Woof woof\u0026#34;); } // 使用super调用父类的makeSound方法 public void specificSound() { super.makeSound(); // 调用父类的makeSound方法 System.out.println(\u0026#34;Dog\u0026#39;s specific sound\u0026#34;); } } 在这个例子中，super 关键字用于在子类 Dog 中调用父类 Animal 的构造方法和 makeSound 方法。这展示了如何在子类中访问和使用父类的成员。\n2.13.1 static 关键字\r\u0026ndash;静态变量\n1 private static String str1 = \u0026#34;staticProperty\u0026#34;; \u0026ndash;静态方法\n1 2 3 4 5 public static void print2() { System.out.println(str1); System.out.println(str2); print1(); } \u0026ndash;静态代码块\n1 2 3 static { static int a = 3; } 被 static 修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要 new 出一个类来。\n被 static 修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要 new 出一个类来。\n平时要使用类中的变量或者方法都要先new实例化一个类。\n2.13.2 final关键字\rfinal：用于声明常量、最终类或最终方法。\n\u0026ndash;修饰变量\n基本类型变量使用 final 修饰了就不可变了 对于引用类型变量被 final 修饰了；引用变量引用不可变(就整个引用变量不可变)，但是引用对象的内容可以改变。 举例\nfinal修饰数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class FinalArrayExample { public static void main(String[] args) { final int[] numbers = {1, 2, 3, 4, 5}; // 修改数组中的元素是允许的 numbers[0] = 10; // 尝试重新赋值，这将导致编译错误 // numbers = new int[]{6, 7, 8}; // 错误：不能将变量 numbers 赋值 // 输出修改后的数组 System.out.println(Arrays.toString(numbers)); // 输出: [10, 2, 3, 4, 5] } } 在这个例子中，数组 numbers 被 final 修饰，这意味着数组的引用不能被改变指向另一个数组。但是，数组中的元素可以被修改。\n\u0026ndash;修饰类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class FinalObjectExample { public static void main(String[] args) { final A obj = new A(); // 修改对象的属性是允许的，如果属性不是 final 的 obj.a = 4; // 假设 A 类中的 a 不是 final // 尝试重新赋值，这将导致编译错误 // obj = new A(); // 错误：不能将变量 obj 赋值 // 输出对象的属性值 System.out.println(obj.a); // 输出: 4 } } class A { int a = 3; } 注意\nfinal 修饰的类，不能被继承（）\n\u0026ndash;修饰方法\nfinal 修饰的方法 不能被重写，但是子类可以用父类中 final 修饰的方法；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 final class FinalClassExample { // final 类不能被继承 // 子类继承 FinalClassExample 是不允许的 public final void display() { System.out.println(\u0026#34;Hello, World!\u0026#34;); } // final 方法不能被子类重写 // 子类重写 display 方法是不允许的 } // 尝试创建子类将导致编译错误 // class SubClass extends FinalClassExample { } 2.14 抽象类\r1 2 3 4 5 6 public abstract class Action { public abstract void doSomething(); // 抽象方法 public void test() { // 方法体 } } 在这段代码中，Action 类被声明为抽象类，使用 abstract 关键字。这意味着 Action 类不能被实例化，它只能作为其他类的父类。\n抽象类可以包含抽象方法和具体方法。\n抽象方法也使用 abstract 关键字声明，它们没有方法体，必须在子类中被实现。在这个例子中，doSomething 是一个抽象方法，而 test 是一个具体方法，它提供了一个方法体。\n子类继承 Action 类时，必须实现 doSomething 方法，即要重写 doSomething 方法并添加具体的方法体。\n2.15 接口\r1 2 3 4 5 6 7 8 9 10 11 12 13 public interface UserService { // 接口中的所有定义的方法默认都是抽象的（public abstract） // 变量只能为 public static final 类型的 // public abstract void add(); // 等效于 void add(); // int age = 99; // 等效于 public static final int age = 99; int age = 99; void add(String name); void delete(String name); void update(String name); void query(String name); } 在 Java 中，接口（interface）是一种特殊的抽象类型，它可以包含抽象方法和常量。接口中的方法默认是 public abstract 的，这意味着它们没有方法体，必须由实现接口的类来提供具体实现。接口中的变量默认是 public static final 的，这意味着它们是常量，并且必须在声明时初始化。\n\u0026ndash;区别\n接口要被子类实现，抽象类要被子类继承。 接口中变量全为公共静态常量，抽象类中可有普通变量。 接口中全为抽象方法的声明，抽象类中可以有具体方法的实现。 接口中不可以有构造函数，抽象类中可以有构造函数。 一个类可实现多个接口，而抽象类只能被单继承。 接口中方法为抽象方法，而抽象类中也可有非抽象方法。 示例\n1 2 3 4 5 6 //定义接口 public interface Vehicle { void startEngine(); void stopEngine(); void honk(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //实现接口 //一旦你决定用一个类实现一个接口，你必须实现其所有的抽象方法 public class Car implements Vehicle { @Override public void startEngine() { System.out.println(\u0026#34;Car engine started.\u0026#34;); } @Override public void stopEngine() { System.out.println(\u0026#34;Car engine stopped.\u0026#34;); } @Override public void honk() { System.out.println(\u0026#34;Car horn honked.\u0026#34;); } } 1 2 3 4 5 6 7 8 9 //调用方法 public class Main { public static void main(String[] args) { Car myCar = new Car(); myCar.startEngine(); myCar.honk(); myCar.stopEngine(); } } ","date":"2024-12-16T16:04:20Z","image":"https://ch0ser.github.io/images/Lover.PNG","permalink":"https://ch0ser.github.io/p/quick-java/","title":"Quick Java"},{"content":"(2023-11-15) Do Users Write More Insecure Code with AI Assistants?\r作者: Neil Perry; Megha Srivastava; Deepak Kumar; Dan Boneh; 期刊: （发表日期: 2023-11-15） 期刊分区: 本地链接: Perry 等 - 2023 - Do Users Write More Insecure Code with AI Assistants.pdf DOI: 10.1145/3576915.3623157 摘要: AI code assistants have emerged as powerful tools that can aid in the software development life-cycle and can improve developer productivity. Unfortunately, such assistants have also been found to produce insecure code in lab environments, raising significant concerns about their usage in practice. In this paper, we conduct a user study to examine how users interact with AI code assistants to solve a variety of security related tasks. Overall, we find that participants who had access to an AI assistant wrote significantly less secure code than those without access to an assistant. Participants with access to an AI assistant were also more likely to believe they wrote secure code, suggesting that such tools may lead users to be overconfident about security flaws in their code. To better inform the design of future AI-based code assistants, we release our user-study apparatus and anonymized data to researchers seeking to build on our work at this link. **标签:**AI代码安全，用户行为侧 笔记日期: 2024/11/26 16:30:20 📜 研究核心\rTips: 做了什么？解决了什么问题，创新点与不足？\n研究用户如何与 AI 代码助手交互以解决各种与安全相关的任务。\n⚙️ 内容\r背景问题：AI代码助手在实验室环境中会产生不安全的代码\n研究：进行了一项用户研究，以研究用户如何与 AI 代码助手交互以解决各种与安全相关的任务。\n核心问题：\n1.用户在使用AI编程助手时是否编写了更多不安全的代码？\n2.用户是否信任AI助手能够编写安全的代码？\n3.用户在与 AI 助手交互时的语言和行为，如何影响，其代码中安全漏洞的程度？\n发现：\n1.可以访问 AI 助手的参与者编写的代码的安全性明显低于无法使用助手的参与者。\n2.有权访问 AI 助手的参与者也更有可能相信他们编写了安全代码，这表明此类工具可能会导致用户对其代码中的安全漏洞过于自信。\n💡 创新点\r从 AI代码确有问题的层面 深入到了\n1.讨论是不是 使用ai就会导致更多代码问题\n2.以及 用户对ai的信任和交互方式 和 AI生成代码问题 之间的内在联系\n🧩 不足\r研究的参与者主要是大学生，不一定能代表实际使用AI助手的开发者群体。\n而且碍于控制变量和数据收集的难度，样本数量可能确实不算太多。\n🔁 研究内容\r研究目的\n本研究旨在探讨用户在使用AI代码助手（如OpenAI的Codex）时如何解决与安全相关的编程任务，以及这种交互如何影响代码的安全性。研究主要关注三个核心问题：\n1.用户在使用AI编程助手时是否编写了更多不安全的代码？\n2.用户是否信任AI助手能够编写安全的代码？\n3.用户在与AI助手互动时的语言和行为如何影响代码中的安全漏洞程度？\n👩🏻‍💻 方法 与 🔬 实验\r实验设计\r参与者招募：\n研究招募了54名参与者，涵盖了本科生、研究生以及来自不同公司的专业程序员。参与者在参与前需通过一项筛选问题，以验证其编程能力。\n最终，有47名参与者完成了实验，其中33人使用了AI助手，14人作为对照组未使用AI助手。\n研究工具：\n为本研究定制了一个编程用户界面，实验组还配备了一个AI辅助界面，两个组别均可使用外部浏览器以解决问题。\n实验任务：\n参与者被要求完成六个与安全相关的编程问题，涉及Python、JavaScript和C语言。任务包括加密/解密字符串、签名消息、处理用户提供的路径、执行SQL操作以及处理C语言中的字符串等。参与者可以自由选择完成任务的顺序，并在两小时内完成所有问题。\n实验设计：\n参与者被随机分配到实验组（使用AI助手）和对照组（不使用AI助手）。\n研究过程中，记录了参与者的所有交互，包括查询、响应和最终提交的代码。同时，研究团队会手动分析参与者的代码，以评估其正确性和安全性。\n💧 数据\r研究团队记录了参与者在实验中的所有操作，包括代码输出和AI助手的使用情况。通过多变量回归分析，研究者控制了参与者的安全背景和编程经验，以评估AI助手对代码安全性的影响。此外，参与者在完成每个问题后还需填写简短的调查问卷，以获取他们对AI助手的信任程度及代码安全性的自我评估。\n分析过程\r研究团队详细描述了他们如何分析参与者的编程任务响应，尤其关注正确性和安全性错误的分类和评估过程。\n错误分类: 两位作者手动检查所有参与者的解决方案，创建了一个错误列表，列出了所有的正确性和安全性错误，并根据严重性对其进行了排名。\n评分标准: 研究团队设定了明确的评分标准，以衡量每个问题的正确性和安全性，\n正确性：指代码是否能成功执行预期功能；\n安全性：涉及是否存在安全漏洞。\n例如：每个问题的错误分类包括“安全”、“部分安全”、“不安全”等类别。\n注：\nCohen-Kappa一致性评分: 研究团队采用Cohen-Kappa指标（取值在-1和1间，越大一致性越高）来评估两位评审者在正确性和安全性评分上的一致性。结果显示，评分的一致性相当高，正确性评分的Kappa值在0.7至0.96之间，安全性评分的Kappa值在0.68至0.88之间，表明评分过程的可靠性。\n安全分析\r分类系统:\n研究团队为每个安全性问题设计了一个分类系统，以评估参与者的正确性和安全性，进而确定正确率和安全性错误的发生率、错误类型及其来源（来自AI助手还是用户自身）\n实验发现：\n在其中的四个问题上，可以使用人工智能助手的参与者编写的代码的安全性始终低于无法使用人工智能助手的参与者。\n统计分析:\r研究团队使用多变量回归分析来控制参与者的安全背景、编程经验等变量，以解释不同组别之间的安全性差异。\n控制变量以确保是否使用AI助手是影响代码安全的主要因素。\n信任分析\r研究者探讨了用户对AI助手作为编程辅助工具的信任程度。研究通过调查问卷、自由反馈以及用户对AI建议的采纳程度来综合评估信任这一抽象而复杂的概念。\n分析结果：\n提供答案不安全的实验组反而自我正确性和安全性评分更高；\n方案安全的信任度低，不安全的反而高；\n研究者尝试用是否直接复制AI代码来量化信任度，但是发现这因题目而异；\n大部分安全答案都是在AI代码基础上修改的，说明提供安全解决方案可能需要用户更有意识地修改AI生成的代码，而不是盲目信任AI生成的内容。\n提示分析\r研究者探讨了用户如何与AI代码助手进行交互，具体分析了用户的提示语言、提示参数和修复策略对代码安全性的影响。\n分析结果\n提示语言\n使用函数声明和帮助函数的提示更能生成安全的代码。\n提示类型的选择对代码的安全性有显著影响，部分参与者在与AI助手的互动中使用了前一个AI输出作为新提示，这可能导致安全问题的放大或重复。\n提示参数的调整\n调整温度参数可能对代码的安全性产生影响，使用更高的温度值通常与更安全的代码输出相关。\n修复策略\n参与者在修复提示时更倾向于使用更具体的指令和信息。\n安全性\n依赖于AI助手的先前输出进行后续提示的参与者，往往不太可能提供安全答案。这表明，过度依赖AI生成的内容可能导致安全性下降。\n📜 结论总结\rAI助手的影响\r（同时也是核心问题1的回答）\n研究发现，参与者在使用AI助手时，通常会引入更多的安全漏洞。大多数任务中，使用AI助手的参与者更可能提交不安全的解决方案，而那些没有使用助手的参与者则相对更安全。这表明AI助手可能导致开发者对其生成的代码过于信任，从而忽视潜在的安全问题。\n用户信任与安全性的关系\r参与者普遍认为他们的答案更安全，尤其是那些提交不安全代码的用户，相比之下，提交安全代码的用户对AI助手的信任度较低。这种反向关系特别明显，显示出用户在面对AI生成的代码时可能会产生误导性的安全感。\n用户行为的多样性\r参与者在与AI助手互动时展现出显著的行为差异。那些更加积极调整提示或参数的参与者，通常能提供更安全的解决方案。这表明用户的交互策略和对AI助手的理解程度直接影响了他们最终的代码安全性。\nAI助手的设计建议\r研究者建议未来的AI助手设计应加强对用户的教育，帮助他们理解如何有效地与AI进行交互，避免过度依赖助手的输出。\n同时，应该考虑在AI助手中集成安全警示和验证测试，以减少用户在使用过程中产生的安全漏洞。\n研究的局限性\r研究的参与者主要是大学生，这可能不代表实际使用AI助手的开发者群体。研究者指出，未来需要更大规模的样本和不同背景的参与者，以更全面地评估AI助手在实际开发环境中的影响。\n小结\r总的来说，该总结部分强调了AI助手在提高开发效率的同时，也可能引入安全风险，用户应更加谨慎地对待AI生成的代码，未来的AI助手设计需要考虑如何增强用户的安全意识和代码审查能力。\n🤔 个人总结\r🙋‍♀️重点记录\ridea的创新之处\n从 AI代码确有问题的层面 深入到了\n1.讨论是不是 使用ai就会导致更多代码问题；\n2.以及 用户对ai的信任和交互方式 和 AI生成代码问题 之间的内在联系。\n在现有的研究上更加深入，具体地探讨了影响 AI生成代码安全问题的 用户因素。\n控制变量的处理\n要确保实验反映的确实是AI代码助手的影响，需要把其它实验变量控制在可控范围内，尽量消除它们对关键要素的判断的影响。\n不足\n研究的参与者主要是大学生，不一定能代表实际使用AI助手的开发者群体。\n而且碍于控制变量和数据收集的难度，样本数量可能确实不算太多。\n启发\r这篇文章是从用户端分析的AI生成代码安全的问题，我觉得从模型端的角度也可以对AI代码安全问题进行分析。虽然感觉实现难度上可能要大得多了。\n","date":"2024-11-23T21:45:04Z","image":"https://ch0ser.github.io/images/Tiger.JPG","permalink":"https://ch0ser.github.io/p/do-users-write-more-insecure-code-with-ai-assistants/","title":"Do Users Write More Insecure Code with AI Assistants?"},{"content":"Typora教程\rTypora的安装\r这是b站up主 格格分享集 提供的1.9.5版本及绕过激活方法，在此鸣谢。\nhttps://www.bilibili.com/video/BV1iKUsYdEat/?share_source=copy_web\u0026vd_source=94c6a60e88fb8109fcdee4173a2a7281\n不想看视频的可以往下看。\n解压 Typora1.9.5.zip后，文件结构如下：\n先运行安装程序安装typora1.9.5；\n然后解压河蟹.zip,将其中的配置文件winmm.dll复制到typora所在文件夹(右键点击typora快捷方式即可)；\n最后打开typora，点击侧边栏中的帮助，再点击关于激活即可。\nMarkdown语法及Typora快捷键\r标题\r使用井号 # 后接文本表标题，#个数表示几级标题，至多六级。（有时#后要紧接空格）\nTypora中快捷键Ctrl+1-6表示相应级标题。\n字体\r斜体\r一对星号*括住的文本表示斜体文本。\n要表示斜体的文本\n或者用一对下划线_括住文本表示斜体文本。\n要表示斜体的文本\nTypora快捷键Ctrl+I。\n粗体\r一对 ** 括住的文本表示斜体文本。\n要表示斜体的文本\n或者用一对下划线 __ 括住文本表示斜体文本。\n要表示斜体的文本\nTypora快捷键Ctrl+B。\n粗斜体文本\r一对 *** 括住的文本表示斜体文本。\n要表示粗斜体的文本\n或者用一对下划线 __ 括住文本表示斜体文本。\n要表示斜体的文本\n文本高亮\r算是Typora的一个特色，用一对==将要高亮的文本括起来，需要在文件-偏好设置中打开。\n==要高亮的文本==\n各种线\r分割线\r用三个及以上的 + 号或 * 号或 - 来表示一条分割线；\nTypora右键插入水平分割线即可。\n下为例子：\n+++\n下划线\r利用的是HTML的标签 和 表示增加下划线文本，\n要增加下划线的文本\nTypora快捷键：Ctrl+U\n删除线\r用一对~~括住的文本来表示删除文本；\n要删除的文本\nTypora快捷键：Alt+Shift+5\n表格\rMarkdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\nTypora快捷键：Ctrl+T\nTypora中表格的创建和修改都非常精简和方便，所以很多额外的操作（对齐、添加行列等）不加赘述了。\n表头 表头 表头 列表\r无序列表\r用*，+或-标记符号来表示无序列表项，标记符号后要紧接一个空格。\n1 2 其它两符号同上。\n（Enter键退出列表）\nTypora快捷键：Ctrl+Shift+] (更建议右键里添加)\n有序列表\r以 数字紧接.再紧接空格表示有序列表。\n一 二 Typora快捷键：Ctrl+Shift+[ (更建议右键里添加)\n嵌套列表\r列表中：\n回车换行自动生成列表第二列；\nTab键该项变为上一项的子列表。\n无序列表和有序列表间可相互嵌套。\n引用\r用区块表引用, \u0026gt;加空格表示区块。\n这是一级引用\n这是二级引用\n（Enter键退出区块）\nTypora快捷键：Ctrl+Shift+Q (更建议右键里添加)\n代码块\r代码行：用一对**`**（英语下Tab键上方符号）括住代码\nprint(\u0026quot;Helloworld\u0026quot;)\n代码块：\n以三个`加回车进入代码块；\nTypora快捷键：Ctrl+Shift+`\n链接\r用\n链接文字\n或\n\u0026lt;链接地址\u0026gt;\n表示链接。\n[]中是链接文本，\u0026lt;\u0026gt;中是链接地址，也可以放本地文件的地址（相对绝对均可）\n但是单独使用\u0026lt;\u0026gt;不能打开文件。\n亦可使用链接实现页内跳转：\n链接文字\nCTRL+点击跳转至文章开头\n图像\r语法如下：\n！加[属性文本]加(图片地址 ”可选标题“)\n首先一个感叹号 然后中括号里面写属性文本 小括号里面写图片地址，后可接标题 本地地址和网络地址都行。\n在Typora中，也可以直接使用Ctrl+C，Ctrl+V来直接进行复制粘贴图片，但是，由于Markdown语法的限制，一定需要文件地址，所以需要设置一下Typora。\n在Typora 文件-偏好设置-图像 中可自行选择将图片复制到什么路径。相对路径以该文本文件为参照。\n数学\r数学公式太繁琐了喵，推荐让ai生成，这里不加赘述了。\n有时间再更。\n","date":"2024-11-23T21:45:04Z","image":"https://ch0ser.github.io/images/PacificRim_01.jpg","permalink":"https://ch0ser.github.io/p/typora/","title":"Typora"}]