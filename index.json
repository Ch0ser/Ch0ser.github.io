[{"content":"Docker命令\rDocker 镜像构建\rdocker build命令是 Docker 引擎的核心命令之一，用于根据 Dockerfile中的指令自动构建 Docker 镜像。\n核心概念与基础语法\r构建上下文：这是 docker build命令中指定的路径（通常是当前目录 .）。Docker 客户端会将这个路径下的所有文件（递归地）打包发送给 Docker 守护进程，因此只有上下文中的文件才能被 Dockerfile中的 COPY或 ADD指令使用。为了提高效率，建议使用空目录作为上下文，或通过 .dockerignore文件排除不必要的文件 Dockerfile：这是一个文本文件，包含了一系列用于构建镜像的指令（如 FROM, RUN, COPY等）。docker build会逐条执行这些指令，每条指令都会创建一个新的镜像层。 基本语法：\n1 docker build [OPTIONS] PATH | URL | - 其中 PATH就是构建上下文的路径。\n常用选项详解\r选项 说明与示例 适用场景 -t/ --tag 为构建出的镜像命名和打标签。格式为 name:tag。示例：docker build -t myapp:latest -t myapp:v1.0 . 镜像版本管理。 -f/ --file 指定要使用的 Dockerfile路径（当 Dockerfile不在上下文根目录或名称非默认时）。示例：docker build -f ./docker/Dockerfile.prod . 项目中有多个不同用途的 Dockerfile。 --build-arg 设置构建时的变量，这些变量可以在 Dockerfile中通过 ARG指令引用。示例：docker build --build-arg NODE_ENV=production . 动态传入构建参数，如版本号、环境变量。 --no-cache 强制忽略之前构建的缓存，执行全新构建。示例：docker build --no-cache . 确保依赖获取最新版本或解决缓存导致的构建问题。 --target 在多阶段构建的 Dockerfile中，只构建到指定的目标阶段。示例：docker build --target builder . 仅构建用于编译的中间阶段，以缩小最终镜像体积。 -q/ --quiet 安静模式，构建成功后只输出最终的镜像ID。 适用于自动化脚本，减少输出信息。 工作原理与流程\r发送上下文：Docker 客户端将整个构建上下文目录打包发送给 Docker 守护进程。因此，避免使用根目录 /作为上下文，以免发送大量无用数据。 逐行执行：守护进程逐条解析并执行 Dockerfile中的指令。 层缓存机制：每条指令都会生成一个只读的镜像层。Docker 会缓存未改变的层，后续构建时直接使用缓存，从而大幅加速构建过程。控制台输出中的 CACHED标识即表示使用了缓存。 输出镜像：所有指令执行完毕后，生成最终的镜像。 示例\r1 2 3 4 # -t 指定镜像名称，标签默认是latest # . 代表上下文默认为当前目录 # 所以要保证dockerfile以及里面要copy和add的文件在当前目录下 docker build -t gpac_cve-2019-20162 . Docker 容器启动\r启动Docker容器有多种方式，具体取决于使用场景和需求。以下是常见的启动容器方法及详细说明：\n基本启动命令\r使用docker run命令创建并启动一个新容器：\n1 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] /bin/bash 常用选项 -d：后台运行（守护态）。 -it：交互式终端（如/bin/bash）。 --name：指定容器名称。 -rm：容器停止后自动删除容器。 -p：端口映射（格式：主机端口:容器端口）。一般容器有通信需求会用 -v：挂载数据卷。 --restart：设置重启策略（如always、unless-stopped）。 /bin/bash：交互式终端进入工作目录。 示例：\n1 2 3 4 5 6 7 # 后台启动Nginx并映射端口 docker run -d --name my-nginx -p 8080:80 nginx # 挂载目录映射到容器内/testspace目录下 # 并且运行后会进入交互式终端（工作目录下） docker run -it --rm --name gpac_cve-2019-20162 \\ -v /mnt/d/A.S.E/benchmark-project/gpac:/testspace \\ gpac_cve-2020-23267 /bin/bash 启动已停止的容器\r若容器已存在但处于停止状态，使用docker start：\n1 docker start \u0026lt;容器ID或名称\u0026gt; 可结合-a参数查看输出日志。 进入运行中的容器\rdocker exec（推荐）：\n在运行中的容器内启动新终端，退出时容器不会停止：\n1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash docker attach： 直接进入容器的主进程终端，退出可能导致容器停止。\n使用Docker Compose启动多容器\r通过docker-compose.yml文件定义服务，一键启动：\n1 docker-compose up -d 适用场景：需编排多个关联容器（如Web+数据库）。 后台运行与资源限制\r后台运行：添加-d参数。 资源限制： 内存：-m 200M --memory-swap=300M。 CPU权重：--cpu-shares 512。 注意事项\r端口冲突：确保主机端口未被占用。 数据持久化：使用-v挂载重要数据，避免容器删除后丢失。 日志排查：启动失败时，通过docker logs \u0026lt;容器ID\u0026gt;查看错误。 Docker 容器/镜像重命名\r在Docker中，重命名容器可以通过以下命令和方法实现：\n使用docker rename命令\r这是最简便的方法，适用于运行中或已停止的容器：\n1 docker rename \u0026lt;旧容器名或ID\u0026gt; \u0026lt;新容器名\u0026gt; 示例：\n1 docker rename my_old_container my_new_container 注意：\n新名称必须唯一，不能与现有容器冲突。 操作不会影响容器内部进程或数据。 停止并重新创建容器\r若需保留原容器的配置，可先停止并删除原容器，再以新名称重新创建：\n1 2 3 docker stop old_container docker rm old_container docker run -d --name new_container [其他选项] \u0026lt;镜像名\u0026gt; 适用场景：需要调整其他参数（如端口、卷）时。 使用Docker Compose\r若容器由docker-compose.yml管理，直接修改文件中的服务名称并重启：\n1 2 3 services: new_name: # 修改此处 image: nginx 然后运行：\n1 docker-compose up -d 优势：适合多容器编排场景。 常见问题\r名称冲突：若新名称已存在，Docker会报错Conflict，需先删除或重名冲突容器。 验证结果：通过docker ps -a确认名称是否更新。 总结\n优先使用docker rename快速重命名；复杂需求（如配置变更）可结合停止重建或Compose调整。确保操作前后验证容器状态。\nDocker 容器提交为镜像\rdocker commit命令允许你直接将一个容器的当前状态（包括文件更改、已安装的软件、配置调整等）保存为一个新的 Docker 镜像。它就像给容器拍了一张快照，便于快速保存或分享特定工作状态。\n1 docker commit [OPTIONS] [容器名称] [镜像名称:tag] 选项 缩写 功能说明 示例 --author -a 指定新镜像的作者信息。 -a \u0026quot;张三 \u0026lt;zhang@example.com\u0026gt;\u0026quot; --message -m 添加提交信息，说明此次更改的内容。 -m \u0026quot;安装了Nginx服务器\u0026quot; --change -c 应用Dockerfile指令（如ENV, EXPOSE, CMD等）。 -c \u0026quot;EXPOSE 8080\u0026quot; --pause -p 提交时是否暂停容器以确保数据一致性（默认为true）。 --pause=false 适用情况：\n快速保存调试环境：当你在容器内进行复杂的配置或调试，并希望保存当前进度时，使用 docker commit可以快速创建一个镜像，下次可以直接从这一步开始，无需重头再来。 紧急热修复：生产环境中的容器出现问题需要立即修复时，你可以进入容器实施修复，然后通过 docker commit快速生成一个包含修复的临时镜像用于部署，为编写正式的 Dockerfile 争取时间。 创建自定义开发环境：基于一个标准镜像（如官方 Python 镜像）启动容器，安装团队所需的各种开发工具和依赖后，提交为一个标准的团队开发环境镜像，方便统一开发环境。 保存难以Dockerfile化的操作：有些交互式安装过程或图形界面软件的配置很难用 Dockerfile 指令完全自动化，这时可以通过交互操作后提交镜像来保存成果。 注意事项\n尽管 docker commit很方便，但也有一些重要的限制和需要注意的地方：\n可重复性差：通过 docker commit创建的镜像构建过程是黑盒的，缺乏像 Dockerfile 那样的声明性和可重复性。他人很难知晓镜像的准确构建步骤。所以在正式规范的团队开发里，还是尽量通过dockerfile来构建镜像。 容易导致镜像臃肿：交互式操作容易引入不必要的临时文件或缓存，如果未及时清理，会使镜像体积迅速膨胀。最佳实践：提交前，尽量清理缓存和临时文件（例如执行 apt-get clean）。 可能存在安全风险：无意中提交的镜像可能包含敏感信息，如密码、密钥等。最佳实践：提交前检查更改，使用 docker diff \u0026lt;容器名\u0026gt;查看文件系统差异，避免提交敏感数据。 不包含卷（Volume）中的数据：docker commit不会保存容器内挂载的卷中的数据。 最后一点补充说明一下，如果你想要保存容器内挂载的卷中的数据，可以用cp指令拷贝进容器内目录。\n1 2 cp [OPTIONS] [源目录] [目的目录] cp -r /testspace/gpac /workspace 前者为被复制的目录（或文件），后者为要复制到的目录 -r /-R：递归复制，用于复制目录和其中所有内容 -f：强制覆盖已存在的目标文件 -n：不覆盖已经存在的目录 Docker 打包镜像\rdocker save是一个非常有用的 Docker 命令，它能将你的 Docker 镜像打包成一个独立的归档文件（tar 格式），非常适合用于镜像的备份、迁移或在离线环境中分发。\n1 2 3 docker save -o [压缩包名称].tar [镜像名称]:[tag] docker save -o my_apps.tar app:v1.0 db:latest docker save redis:alpine \u0026gt; redis.tar -o：将指定标签的镜像保存为指定名称的 .tar文件 多个镜像打包：后面可以接好几个镜像一起打包 使用重定向：使用 Shell 重定向操作，效果与 -o相同 Docker 加载镜像\r1 2 3 docker load -i [压缩包名称].tar # 预计输出 Loaded image: [镜像名称]:[tag] 核心功能是：将 docker save导出的镜像包（如 nginx.tar）恢复至本地镜像库。\n加载过程会完整恢复镜像的所有层（Layers）、标签（Tag）、构建历史等元数据，保持镜像完整性。主要应用于离线环境部署、镜像备份恢复和批量镜像迁移。\n常见问题\n镜像标签为 \u0026lt;none\u0026gt;：有时加载后镜像名称和标签会显示为 \u0026lt;none\u0026gt;。这通常是因为 tar 文件本身未包含标签信息\n。解决方法很简单，使用 docker tag命令手动为其打上标签即可：\n1 2 3 4 5 # 先通过 docker images 查看镜像ID docker images # 然后为指定镜像ID打上标签 docker tag \u0026lt;镜像ID\u0026gt; nginx:latest [1,6](@ref) 加载失败排查：如果加载失败，可以先检查 tar 文件是否完整。可以使用 tar -tf nginx.tar命令查看压缩包内容列表。另外，也要确保 Docker 宿主机有足够的磁盘空间。\nDocker 镜像推送\r推送镜像是将你本地构建好的镜像上传到远程仓库（一般是dockerhub官网），以便他人或其他机器使用。\n登录仓库\n首先需要使用 docker login命令登录到目标镜像仓库（如 Docker Hub 或你的私有仓库）。\n1 2 3 docker login # 或者指定私有仓库地址 docker login myregistry.example.com 执行后会提示输入用户名和密码。如果使用私有仓库，地址需替换为你的仓库地址。\n标记镜像\n在推送之前，必须为本地镜像打上一个符合远程仓库命名规范的标签，格式通常为 [仓库地址]/[用户名或项目名]/[镜像名]:[标签]。当然如果本来就是规范命名就不用改。使用 docker tag命令：\n1 2 3 4 # 语法：docker tag 本地镜像名:标签 新标签 docker tag my-app:latest yourusername/my-app:v1.0 # 如果推送到私有仓库，地址可能如下 docker tag my-app:latest myregistry.example.com/yourproject/my-app:prod 执行推送\n使用 docker push命令将标记好的镜像推送到远程仓库。\n1 docker push yourusername/my-app:v1.0 推送成功后，就可以在远程仓库的页面上看到这个镜像了。\nDocker 拉取镜像\r拉取镜像是从远程仓库将镜像下载到本地环境的过程。\n基本拉取命令\n最基础的命令是 docker pull，后面跟上镜像的名称和标签（可选，默认为 latest）。\n1 2 3 4 5 6 # 拉取官方Nginx镜像的最新版本 docker pull nginx # 拉取指定标签的镜像 docker pull nginx:1.27.0-perl # 从私有仓库拉取 docker pull myregistry.example.com/yourproject/my-app:prod 验证拉取结果\n拉取完成后，使用 docker images命令可以查看本地已下载的镜像列表，确认镜像是否成功拉取。\nDocker镜像拉取失败解决方案\r如果docker镜像拉取失败，且报错为连接超时，无法连接，可以采取以下办法。\n1.排查DNS\n1 sudo nano /etc/resolv.conf 如果resolv.conf中没有8.8.8.8和8.8.4.4，就添上。\n1 2 nameserver 8.8.8.8 nameserver 8.8.4.4 改完后，ctrl+o保存，再enter确认，最后ctrl+x退出。\n此修改在系统重启时会重置，其实也可以永久修改，但是比较麻烦，要拉取的时候修改即可。\n2.修改拉取源\n1 sudo nano /etc/docker/daemon.json 添加国内镜像站：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://dockerproxy.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://docker.nju.edu.cn\u0026#34;, \u0026#34;https://iju9kaj2.mirror.aliyuncs.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://cr.console.aliyun.com\u0026#34;, \u0026#34;https://hub.docker.com\u0026#34;, \u0026#34;http://mirrors.ustc.edu.cn\u0026#34; ] } 改完后，ctrl+o保存，再enter确认，最后ctrl+x退出。\n3.重启docker服务\n1 2 3 4 # 重新load daemon.json sudo systemctl daemon-reload # 重启docker服务 sudo systemctl restart docker 这个时候再试试拉取，多半成功了。\n","date":"2025-10-06T21:56:04Z","image":"http://localhost:1313/images/wave.png","permalink":"http://localhost:1313/p/docker-commands/","title":"Docker Commands"},{"content":"Git使用教程\r安装\r官网下载安装即可，安装配置基本默认。\nhttps://git-scm.com\n常用命令\r命令 描述 git config --global user.name 用户名 设置用户签名 git config --global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m \u0026quot;日志信息\u0026quot; 文件名 提交到本地库 git reflog / git log 查看历史记录 git reset --hard 版本号 版本穿梭 基本操作\r设置用户签名\r1 2 git config --global user.name user_name git config --global user.email user_email git config --global 命令的作用范围是针对 该设备上所有 Git 仓库 的全局配置。\n所以只要配置一次就好了。\n要查看当前的 Git 全局配置，可以使用以下命令：\n1 git config --global --list 查看特定配置项\n如果你只想查看某个特定的全局配置项，可以使用以下命令：\n1 git config --global [配置项名称] 例如：\n1 git config --global user.name 这将只显示全局配置中的用户名。\n初始化本地库\r1 git init 在对应项目文件夹目录下创建Git仓库。\n查看本地状态\r1 git status git status 命令用于显示当前 Git 仓库的状态。它会告诉你哪些文件被修改了、哪些文件被添加到暂存区（staging area）、哪些文件未被跟踪等信息。\n以下是 git status 可能显示的一些关键信息：\n当前分支： 显示你当前所在的分支名称。 本地更改： 未跟踪的文件：显示仓库中尚未添加到暂存区的新文件。 修改过的文件：显示自上次提交以来已被修改的文件。 暂存区更改： 已暂存的更改：显示已被添加到暂存区的文件，这些更改将在下一次提交时被包含。 已暂存但修改过的文件：显示已暂存但自暂存后又被修改的文件。 冲突： 如果你在合并或拉取时遇到冲突，git status 会显示这些冲突文件，提示你需要手动解决这些冲突。 分支状态： 如果你的分支与远程分支有差异，git status 会显示这些差异，例如本地分支领先、落后或与远程分支同步。 未暂存的更改： 显示自上次提交以来未被添加到暂存区的文件更改。 提示信息： 根据当前状态，git status 可能会提供一些有用的提示信息，例如如何添加文件到暂存区或如何提交更改。 添加到暂存区\r1 git add 文件名 git add 是一个 Git 命令，用于将更改添加到暂存区（staging area），这是提交（commit）更改到本地仓库之前的一个必备步骤。它允许你精确控制哪些更改应该包含在下一次提交中。\n暂存区是一个文件，保存了下次将提交到本地仓库的更改列表。\n添加单个文件：\n1 git add \u0026lt;文件名\u0026gt; 这会将指定文件的更改添加到暂存区。\n添加多个文件：\n1 git add \u0026lt;文件1\u0026gt; \u0026lt;文件2\u0026gt; ... 你可以一次性添加多个文件到暂存区。\n添加所有更改：\n1 git add . 或者\n1 git add -A 这会将所有新的、修改的和删除的文件（不包括未跟踪的文件）添加到暂存区。\n提交到本地库\rgit commit 用于将暂存区（staging area）的更改提交（commit）到本地仓库。提交是版本控制中保存项目历史记录的基本单元。\n1 git commit -m \u0026#34;提交信息\u0026#34; 这将提交暂存区的更改，并使用提供的提交信息。-m 选项允许你在命令行中直接添加提交信息，而不需要打开文本编辑器。\n查看历史记录\rgit reflog 和 git log 都是 Git 中用于查看项目历史记录的命令，但它们的用途和显示的信息有所不同。\ngit reflog\ngit reflog 命令显示了所有引用（包括分支和标签）的更新历史。它记录了HEAD和分支引用的每一次移动，无论这些移动是否由提交引起。\ngit reflog 可以显示由于各种操作（如提交、回退、创建分支、切换分支等）引起的引用变化。\n1 git reflog 这将显示一个按时间排序的列表，列出了HEAD和分支引用的每一次更新。\ngit log\ngit log 命令显示了提交历史，包括每次提交的作者、日期、提交信息等详细信息。它主要用于查看项目的提交历史。\n1 git log 这将显示项目的提交历史，包括每次提交的哈希值、作者、日期和提交信息。并且git log还支持多种格式：可以通过选项自定义输出格式，如简洁格式、一行列格式等，并且支持过滤：可以通过选项过滤特定的提交，如按作者、日期、路径等过滤。\n常用选项\n--oneline：以一行列格式显示提交信息，只显示哈希值和提交信息。\n查看简洁的提交历史：\n1 git log --oneline --graph：显示分支合并图。\n查看带有分支合并图的提交历史：\n1 git log --graph --oneline --since 和 --until：按时间过滤提交。\n--author：按作者过滤提交。\n--grep：搜索提交信息中的关键词。\n搜索特定作者的提交：\n1 git log --author=\u0026#34;用户名\u0026#34; 查看特定时间段内的提交：\n1 git log --since=\u0026#34;2024-01-01\u0026#34; --until=\u0026#34;2024-12-31\u0026#34; 版本穿梭\r1 git reset --hard 版本号 上述命令用于将当前分支和工作目录重置到指定的版本号，即某个特定的提交（commit）。这个命令会改变当前分支的 HEAD 指针，并且会重置工作目录和暂存区，使其与指定的提交完全一致。注意，这意味着所有在该提交之后所做的更改都将丢失，包括未提交的更改和暂存的更改，这是不可逆的。\n你需要找到你想要回退到的版本号，可以通过 git log 命令查看提交历史，找到对应的提交哈希值。\n分支操作\r分支的好处\n同时并进行多个功能开发，提高了开发效率 各个分支再开发过程中，如果某个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可 分支常用命令\r命令 描述 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 需要合并的分支名 把指定的分支合并到当前分支上 查看分支\r1 2 git branch -v git branch git branch -v 命令用于列出 Git 仓库中的所有分支，并显示每个分支的最新提交信息。这个命令是 git branch 命令的一个变体，其中的 -v 选项代表“verbose”，即详细模式。\n创建分支\r1 git branch 分支名 git branch 分支名 是一个用于创建新分支的 Git 命令。当你想要从当前开发线（通常是主分支）创建一个新的开发线时，这个命令非常有用。\n这将在当前 HEAD 指向的提交处创建一个新分支，但不会自动切换到该分支。\n切换分支\r1 git checkpoint 分支名 这将切换到指定的分支，并更新工作目录以反映该分支的状态。\n合并分支\r1 git merge 需要合并的分支名 //把指定的分支合并到当前分支上 git merge 用于将一个分支的更改合并到当前分支。这通常用于合并功能分支到主分支（如 main 或 master），或者合并修复分支到开发分支。\n合并过程中的冲突\n在合并过程中，如果存在冲突（即两个分支对同一文件的同一部分进行了不同的更改），Git 会停止合并并让你手动解决这些冲突。你需要：\n手动解决冲突：打开冲突的文件，手动编辑以解决冲突。 标记冲突已解决：使用 git add 命令将解决冲突后的文件标记为已解决。 完成合并：使用 git commit 命令完成合并。 远程仓库的操作\r添加远程库地址\r1 git remote add origin 远程库地址 git remote add origin 远程库地址 用于将远程仓库添加到你的本地 Git 仓库中。当你创建一个新的本地仓库并希望将其与远程仓库（如 Gitee、GitHub、GitLab 等）关联时，这个命令非常有用。\n命令解释\ngit remote：这是用于管理远程仓库引用的命令。 add：这个子命令用于添加一个新的远程仓库引用。 origin：这是远程仓库的默认短名称。Git 使用 origin 作为远程仓库的默认名称，但你也可以使用其他名称。 远程库地址：这是远程仓库的 URL 地址。 验证远程仓库\n添加远程仓库后，你可以使用以下命令来查看所有远程仓库的 URL：\n1 git remote -v 这将列出所有远程仓库的名称和对应的 URL。\n修改远程仓库 URL\n如果你需要修改远程仓库的 URL（例如，从 HTTPS 更改为 SSH），你可以使用以下命令：\n1 git remote set-url origin 新的远程库地址 将 新的远程库地址 替换为你新的远程仓库 URL。\n删除远程仓库\n如果你不再需要某个远程仓库，你可以使用以下命令删除它：\n1 git remote remove origin 这将删除名为 origin 的远程仓库引用。\n拉取远程库文件\r1 git pull origin master 这个命令会从远程仓库的 master 分支拉取最新的更改，并尝试将这些更改合并到你当前所在的本地分支。(有时是用main分支)\n简言之就是从远程库拉取文件到工作区。\n上传远程库文件\r1 git add . //将所有改变添加到暂存区 上传前要执行git add 将更改添加到暂存区（staging area）。\n1 git commit -m \u0026#34;message\u0026#34; 再执行git commit 将暂存区（staging area）的更改提交（commit）到本地仓库。\n1 git push origin (master/分支的名字) 最后执行git push将本地库文件上传到远程库。\n1 git push -u origin 分支名 这条命令做了两件事：\n推送分支：将您的本地分支推送到远程仓库 origin。 设置上游分支：-u 参数将远程分支设置为本地分支的上游分支，这样您以后可以直接使用 git push 或 git pull 命令而不需要指定远程仓库和分支名。 ","date":"2025-02-21T20:58:54Z","image":"http://localhost:1313/images/PacificRim_02.PNG","permalink":"http://localhost:1313/p/quick-git/","title":"Quick Git"},{"content":"1 Java背景知识\r1.1 JDK JRE JVM\rJDK(开发工具包) JRE(运行环境)运行时类库 JVM(Java虚拟机) JDK:（Java Development Kit）\nJava标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。\nJRE:（Java Runtime Environment）\nJava运行环境，用于解释执行Java的字节码文件。\nJVM: (Java Virtual Machine)\nJava虚拟机，是JRE的一部分，负责解释执行字节码文件，是可运行Java字节码文件的虚拟计算机。\n区别联系：（问答题会考可能）\nJDK包含JRE，JDK和JRE中都包含JVM。JDK除了包含JRE还包含一些常用开发工具和基础类库。\nJDK用于开发，JRE用于运行Java程序。\nJVM是Java编程语言的核心并且具有平台独立性。\n1.2 开发Java程序需要的3个步骤：\r编写源文件 编译源文件生成字节码 加载运行字节码 1.3 Java程序运行过程:\r1 javac:\tjava源文件-\u0026gt;class字节码文件(0,1) 2 java: 运行class文件\n1.4 java程序语句执行的顺序\rjava程序语句执行的顺序包括4种基本控制结构：顺序结构、选择结构、循环结构、异常处理逻辑结构。 如果三个空（那就顺序 选择 循环）\n2 编程基础\r2.1 Java的基本语法\r\u0026ndash;方法格式\r1 2 3 4 权限修饰符 返回值声明 方法名称(参数列表){ 方法中封装的逻辑功能; return 返回值; } \u0026ndash;权限修饰符\r下表为Java访问控制符的含义和使用情况\n访问级别 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × default也叫友好型\n\u0026ndash;注释\r// 单行注释 /* 多行注释 /\t/* 文档注释 */\n\u0026ndash;关键字\r关键字 含义 private 私有的 protected 受保护的 public 公共的 abstract 声明抽象 class 类 extends 继承、扩展 final 最终、不可改变 implements 实现 interface 接口 native 本地 new 新，创建 static 静态 strictfp 严格，精准 synchronized 线程、同步 transient 短暂 volatile 易失 程序控制语句 含义 break 跳出，中断 continue 继续 return 返回 do 运行 while 循环 if 如果 else 否则 for 循环 其它关键字 含义 instanceof 实例 switch 观察 case 返回观察里的结果 default 默认 try 捕获异常 catch 处理异常 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 import 引入 package 包 boolean 布尔型 byte 字节型 char 字符型 double 双精度 float 浮点 int 整型 long 长整型 short 短整型 null 空 TRUE 真 FALSE 假 super 父类，超类 this 本类 void 无返回值 goto 跳转 const 静态 native 本地 \u0026ndash;标识符\r(你自己定义的一个东西的名字(比如类名，方法名，变量名，接口名，常量名\u0026hellip;))\n\u0026ndash;注意事项定义的时候:\n示识符:\n由字母、数字、下划线(_)和美元符号($)组成。\n不能以数字开头。\n不能是Java中的关键字。\n2.2 变量 常量\r\u0026ndash;变量的定义\r按所属的数据类型划分：\n基本数据类型变量 引用数据类型变量 按被声明的位置划分：\n局部变量：方法或语句块内部定义的变量\n成员变量：方法外部、类的内部定义的变量\n基本数据类型\n类型 名称 含义 bit 字节数 值范围 整型 byte 字节 8 1字节 -128 到 127 整型 short 短整型 16 2字节 -32768 到 32767 整型 int 整型 32 4字节 -2,147,483,648 到 2,147,483,647 整型 long 长整型 64 8字节 -9223372036854775808 到 922337203685477580 浮点型 float 浮点数 32 4字节 有效位数15位 浮点型 double 双精度浮点数 64 8字节 有效位数15位 字符 char 字符 16 2字节 Unicode字符集 布尔型 boolean 布尔型 1 true/false 布尔型（boolean）的字节数在Java中并不是精确定义的，它是一个特殊的类型，用于表示真（true）或假（false）。在Java虚拟机（JVM）中，boolean的存储可能与其他基本类型不同，且其大小可能依赖于JVM的实现。在实际应用中，boolean通常用于逻辑判断，而不是进行数值计算。\n引用数据类型\n在 Java 中，引用类型（Reference Types）是指那些不是基本数据类型（如 int、char、double 等）的类型。引用类型包括以下几种：\n类（Class）：用户自定义的类，例如 public class A {...} 中的 A 类。\n接口（Interface）：定义了一组方法规范，但不提供实现的类型。\n数组（Array）：存储固定大小的相同类型元素的集合，例如 int[] numbers = new int[10];。\n枚举（Enum）：一种特殊的类类型，其值是固定的常量，例如 enum Day { MONDAY, TUESDAY, WEDNESDAY, ... };。\n注解（Annotation）：一种特殊的接口类型，用于提供元数据，例如 @Deprecated。\n字符串（String）：虽然 String 在 Java 中是不可变的，但它是一个引用类型，用于表示字符序列。\n\u0026ndash;变量的类型转换\rboolean 类型不能转换成任何其它数据类型。\n自动类型转换\n容量小的类型自动转换成容量大的数据类型 byte, short, int -\u0026gt; float -\u0026gt; long -\u0026gt; double byte, short, int 不会互相转换，它们三者在计算时会转换成 int 类型\n显式类型转换\n容量大的类型转换成容量小的数据类型时，要加上强制转换符(截断转换)\n1 2 float b = 3.0f a = (int)b \u0026ndash;变量的作用域\r成员变量(全局变量 private int i=0;)或静态变量 private static String name=\u0026ldquo;list\u0026rdquo;) 在类体内定义的变量称为成员变量，它们作用域是整个类 局部变量 在一个方法或方法内代码块中定义的变量称为局部变量 \u0026ndash;Java中的常量\r(不怎么考)\n常量不能被转换，例如常数\n\u0026ndash;注意事项\r1 2 3 4 变量定义注意事项： float a=13.3f 带上\u0026#39;f\u0026#39; long a=222222222222L 带上\u0026#39;L\u0026#39; char c= \u0026#39;A\u0026#39; 带上\u0026#39; \u0026#39; 2.3 运算符\r算数\r1 2 + - * / % ++ -- / 取商 ；% 取余 赋值\r=\n关系\r\u0026lt; \u0026gt;= \u0026lt;= == !=\n逻辑\r! \u0026amp;\u0026amp; ||\n\u0026amp; |\t不怎么用\n^ 按位异或运算符,逻辑异或运算符\n位运算符(不会考)\n~ \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\n条件运算符\rcondition ? valueIfTrue : valueIfFalse;\ncondition：一个布尔表达式，其结果为 true 或 false。 valueIfTrue：如果 condition 为 true，则这个值会被选择。 valueIfFalse：如果 condition 为 false，则这个值会被选择。 1 2 int score = 85; String grade = score \u0026gt;= 90 ? \u0026#34;A\u0026#34; : \u0026#34;B\u0026#34;; 在这个例子中，如果 score 大于或等于90，grade 将被赋值为 \u0026quot;A\u0026quot;；否则，它将被赋值为 \u0026quot;B\u0026quot;。\n2.4.1 选择语句\r1 2 3 4 5 6 7 8 9 10 11 if else if\t(接在if后面，多重选择) else 这三个与c语言基本相同 switch(XX) { //java特有 枚举 short byte int char String //C语言:字符,int case 1: XX;break; case 2: XX;break; default(可有可无): XX break; } 2.4.2 java的循环\r1 2 3 4 while(){} for(){} do{} while() 以上三种和c语言基本一样 1 2 3 for (ElementType element : collection) { // 在这里处理集合中的每个元素 } ElementType：表示集合中元素的数据类型。 element：表示当前遍历到的集合元素的变量。 collection：表示要遍历的数组或集合。 1 2 3 4 5 6 7 8 9 int[] numbers = {1, 2, 3, 4, 5}; for (int number : numbers) { System.out.println(number); } List\u0026lt;String\u0026gt; words = Arrays.asList(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;Java\u0026#34;); for (String word : words) { System.out.println(word); } 2.5 数组\r-不允许在前面的括号写元素个数\n2.5.1 多维数组初始化3种方式\r\u0026ndash;动态两种\njava的多维数组每一维数可不同\n1 2 3 4 5 1 int[][] arr = new int[3][]; //指定了行数，未指定列数 arr[0] = new int[3];//第0行3列 arr[1] = new int[2];//第1行2列 arr[2] = new int[1];//第2行1列 1 2 3 2 int[][] arr2 = new int[3][2];//同时指定行数和列数 arr[0][0] = 33;//单独对元素赋值 \u0026ndash;静态一种\n1 2 int arr4[][] = new int[][]{{1, 2, 3}, {2, 3}}; //第0行是{1，2，3}，第1行是{2，3} 不赋值默认元素为0\n一般来说初始化时都默认括号在数组名前，这是Java的风格，当然反过来也一样可行（c语言风格）\n2.5.2 数组的常见操作\r声明数组：\n1 int arr[] 数组初始化：\n1 2 int[] arr={1,2,3,4}; int[] arr=new int[]{1,2,3,4}; 查看数组长度：\n1 2 arr.length; 返回值是整数，反映了数组中第一维元素的个数 for each 循环：\n1 2 3 for(int a:arr){ System.out.println(a); } 数组拷贝：\n1 2 3 4 int[] arr2=arr1; 或 int[] arr2=Arrays.copyOf(arr, arr.length(自定义长度)); arr2会复制arr1 length长度的元素 数组排序：\n1 2 Arrays.sort(arr); 默认从小到大排序 将int数组转换为字符串：\n1 2 Arrays.toString(arr); 连括号一起转换成字符串了 2.6 输入输出\r输入\r1 2 Scanner s = new Scanner(System.in); //先创建了一个Scanner对象s，用于从System.in（标准输入流，即键盘输入）读取数据。 在Java中，Scanner 类的 next() 方法用于从输入流中读取下一个完整的 token。Token 通常是输入中的一个单词，由空白字符（如空格、制表符或换行符）分隔。next() 方法会读取并返回一个字符串，直到遇到下一个空白字符，但不包括这个空白字符。（类比scanf）\n1 2 3 4 String word = s.next(); // 从标准输入读取一个单词 System.out.println(\u0026#34;输入的单词是: \u0026#34; + word); //输出 如果需要读取包含空格的字符串，应该使用 nextLine() 而不是 next()。\n它将读取输入直到遇到换行符（\\n），并将换行符之前的所有内容（包括空格）作为字符串返回。\n1 String sentence = s.nextLine(); // 读取整行，包括空格 在s.next()的基础上，有：\n1 2 3 4 5 6 s.nextInt(); //读取用户输入的下一个整数 s.nextFloat(); //读取用户输入的下一个浮点数。这可以是单个数字、小数或科学记数法表示的数字 //即： s.next类型名(); Scanner 类的 hasNext() 方法用于检查输入流中是否还有更多的输入。这是一个非常有用的功能，尤其是在处理不确定数量的输入时，比如在读取用户输入直到用户决定停止时。\n1 2 3 4 5 6 7 8 Scanner s = new Scanner(System.in); while (s.hasNext()) { String input = s.next(); if (\u0026#34;end\u0026#34;.equals(input)) { break; // 结束循环 } System.out.println(\u0026#34;处理输入: \u0026#34; + input); } 同理有：hasNextLine() hasNextFloat()等方法检验有无特定类型的输入\n这里插入一下字符串的比较，equals()方法\n1 2 3 4 5 boolean areEqual = str1.equals(str2); //若str1与str2内容相同，返回true，反之返回false //注意：空值检查 //如果 equals 方法的参数是 null，那么在没有进行空值检查的情况下直接调用会导致 NullPointerException。 //因此，通常在调用 equals 方法之前，会先检查参数是否为 null。 输出\r在Java中，输出数据到控制台或文件可以通过多种方式实现。以下是一些输出方法：\nSystem.out.print 和 System.out.println：（常用）\nSystem.out.print：将数据打印到标准输出（通常是控制台），但不换行。 System.out.println：将数据打印到标准输出，并在末尾添加一个换行符。 1 2 System.out.print(\u0026#34;Hello, \u0026#34;); System.out.println(\u0026#34;World!\u0026#34;); System.out.printf：\n用于格式化输出，类似于C语言中的 printf 函数。可以指定输出格式和宽度等。 1 System.out.printf(\u0026#34;The value of pi is: %.2f%n\u0026#34;, Math.PI); System.out.format：\n类似于 System.out.printf，但返回 String 对象而不是打印到控制台。 1 String formattedString = System.out.format(\u0026#34;The value of pi is: %.2f%n\u0026#34;, Math.PI); PrintStream：\nSystem.out 是一个 PrintStream 对象，提供了更多的方法来控制输出，如 print, println, printf, format 等。 BufferedWriter：\n用于将文本写入字符输出流，可以提高写入性能，特别是当写入大量数据时。 1 2 3 4 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out)); writer.write(\u0026#34;Hello, World!\u0026#34;); writer.newLine(); // 写入换行符 writer.flush(); // 清空缓冲区 PrintWriter：\n用于打印格式化表示的字符到控制台或文件。 1 2 3 PrintWriter writer = new PrintWriter(System.out, true); writer.println(\u0026#34;Hello, World!\u0026#34;); writer.flush(); // 清空缓冲区 FileWriter：\n用于写入字符到文件。 1 2 3 FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;); writer.write(\u0026#34;Hello, World!\u0026#34;); writer.close(); // 关闭文件写入器 Files.write (Java 7+)：\n用于将字节数据写入文件，可以指定字符编码。 1 2 Path path = Paths.get(\u0026#34;output.txt\u0026#34;); Files.write(path, \u0026#34;Hello, World!\u0026#34;.getBytes(StandardCharsets.UTF_8)); Logger：\nJava的日志记录框架，用于记录应用程序的日志信息。 1 2 Logger logger = Logger.getLogger(\u0026#34;MyLogger\u0026#34;); logger.info(\u0026#34;Hello, World!\u0026#34;); StringBuffer 和 StringBuilder：\n用于在内存中构建字符串，特别是当需要多次修改字符串内容时。 1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello, \u0026#34;); sb.append(\u0026#34;World!\u0026#34;); System.out.println(sb.toString()); 选择哪种输出方法取决于你的具体需求，比如是否需要格式化输出、是否需要写入文件、是否需要考虑性能等因素。\n2.7.1 类与对象\r概念 三大特征 封装 “通过 private、default、protected、public 关键字实现属性或方法的封装，仅对外提供公共访问方式。” “高内聚、低耦合”\n封装的好处：\n实现数据和方法的隐藏 实现信息隐藏，允许外部对类有限的访问，开发者可以自由的改变类的内部实现 提高了代码的重用性 继承\n通过 extends。 两个好处：\n代码重用了。 通过继承，实现对现实世界更加准确的建模。 多态\n多态是指允许不同类的对象对同一消息做出响应，即同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果。在Java中多态的实现方式：接口实现，继承父类进行方法重写。同一个类中进行方法重载，父类引用指向子类对象。\n2.7.2 类与对象 (重点)\r关系\n实例化(对象的创建)\n通过 new 关键字创建 比如\n1 2 Student zhangchunhui = new Student(); zhangchunhui.setAge(20); 1 2 3 4 5 6 class Student{ private int age; public static void setAge(int age){ this.age = age; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Stu{ //1 属性设为私有 private int age; //2 方法 get set 你自己定义的 public void setAge(int age) { this.age = age; } public int getAge() { return this.age; } //我自己定义的方法 public void myPrint() { System.out.println(\u0026#34;nihao\u0026#34;); } //3 构造函数 public Stu() { } 或 public Stu(int age) { this.age = age; //类内用this指代该类 } } 若使用无参数构造函数\n1 2 Stu student1 = new Stu(); // 创建了一个Stu对象，但是age属性没有被初始化 student1.setAge(25); // 之后可以手动设置age属性的值 若使用带参数构造函数\n1 Stu student2 = new Stu(20); // 创建了一个Stu对象，并且age属性被初始化为20 类的定义(格式,注意事项)\n1 2 3 4 [修饰符] class 类名 [extends 父类名] [implements 接口名]{ // 类体，包括类的成员变量和成员方法 } //[]表示可选 2.8 类的继承\rObject类\nObject类是所有类的父类，里面有很多方法 clone getClass toString equals hashCode notify notifyAll wait finalize\ngetClass方法 获取运行时类型，返回值为Class对象 hashCode方法 返回该对象的哈希码值，是为了提高哈希表的效率（Hashtable） equals方法 判断两个对象是否相等，在Object类中equals就是使用==去判断，所以在Object的子类中，如果equals相等的两个对象，hashCode一定相等，实现不同的比较。 clone方法 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递。我们有时候不希望在方法里修改参数，这就需要在类中重写clone方法。 如果在clone方法中调用super.clone()方法需要实现Cloneable接口，否则会抛出CloneNotSupportedException。 此方法只实现了一个浅层拷贝，对于基本类型字段成功拷贝，但是如果是数组等对象，只做了浅拷贝，也就是只复制了对象的引用，所以需要自己重写clone方法进行深层拷贝。 toString方法 返回一个String字符串，用于描述当前对象的信息，可以重写该方法返回对自己有用的信息，默认返回的是当前对象的类名+hashCode的16进制数字。 wait方法 多线程中用到的方法，作用是让当前线程进入等待状态，同时也会释放当前线程所持有的锁。直到其他线程调用此对象的notify()方法或notifyAll()方法，当前线程才会被唤醒。 notify方法 多线程时用到的方法，唤醒该对象等待的某个线程 notifyAll方法 多线程时用到的方法，唤醒该对象等待的所有线程 finalize 对象在被垃圾收集器回收前一定会调用finalize方法，对象被释放前最后的挣扎，因为无法确定该方法什么时候被调用，很少使用。 \u0026ndash;类的继承格式\n1 2 3 4 5 class 父类 { } class 子类 extends 父类 { } \u0026ndash;继承了之后有父类(非私有private)的属性或方法,可直接调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Animal { public String name; private int id; public Animal(String myName, String myId) { // 初始化属性值 } public void eat() { } public void sleep() { System.out.println(\u0026#34;晚上了我要睡觉\u0026#34;) } } public class Owl extends Animal{ } \u0026mdash;重写父类方法\n子类可以重写父类的同名方法，以根据需求覆盖原方法\n1 2 3 4 5 public class Penguin extends Animal{ public void sleep() { System.out.println(\u0026#34;白天了我要睡觉\u0026#34;) } } 2.9 类的封装\r将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供getter/setter的方法来对隐藏的信息进行操作和访问。\ngetter setter\n封装的实现步骤：\n(1) 将成员属性的可见性设为（private）\n(2) 创建getter/setter方法（用于属性的读写）（通过这两种方法对数据进行获取和设定，对象通过调用这两种方法实现对数据的读写）\n(3) 在getter/setter方法中加入属性控制语句（对属性值的合法性进行判断）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Person { private String name; private int age; public int getAge() { return age; } public String getName() { return name; } public void setAge(int age) { if(age \u0026lt; 0){ System.out.println(\u0026#34;你的年龄不合法请重新输入\u0026#34;)； } else{ this.age = age; } } public void setName(String name) { this.name = name; } } //通过方法来访问或者修改私有private的属性 2.10 构造方法(重点)\r\u0026ndash;定义\n主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。\n\u0026ndash;重载\n1 2 3 4 5 6 7 8 9 10 11 12 public Animal2(String name, int myid) { this.name = name; this.id = myid; } public Animal2(String name) { this.name = name; } public Animal2(int id2) { this.id = id2; } 2.11 方法的重载 和 重写\r\u0026ndash;回顾一下方法定义格式：\n1 2 3 4 权限修饰符 返回值声明 方法名称(参数列表){ 方法中封装的逻辑功能; return 返回值; } 重载（Overloading）：\n发生在同一个类中，当多个方法有相同的名称但参数列表不同（与返回值类型、修饰符无关）时，这些方法就是重载的。\n重载的目的是为了提供相同功能但使用不同参数的方法，以提高代码的可读性和灵活性。\n示例见下或2.10\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Calculator { // 重载方法1：两个整数相加 public int add(int a, int b) { return a + b; } // 重载方法2：三个整数相加 public int add(int a, int b, int c) { return a + b + c; } // 重载方法3：两个浮点数相加 public double add(double a, double b) { return a + b; } } 重写（Overriding）：\n发生在子类和父类之间，当子类有一个与父类方法签名（方法名称和参数列表）完全相同的方法时，子类的方法就重写了父类的方法。\n重写的目的是为了提供特定于子类的行为，即子类可以根据自己的需要改变父类方法的行为。\n实例见 2.8\n重写的注意事项：\n重写的方法必须要和父类一模一样（包括返回值类型、方法名、参数列表）。 重写的方法可以使用 @Override 注解来标识。 子类中重写的方法的访问权限不能低于父类中方法的访问权限。权限修饰符的顺序是：private \u0026lt; 默认（什么都不写） \u0026lt; protected \u0026lt; public。 2.12.1 this 关键字\rJava 中为解决变量的命名冲突和不确定性问题，引入关键字 this 代表其所在方法的当前对象的引用：\n构造方法中指该构造器所创建的新对象: 1 2 3 4 5 6 7 8 public class B { A a; // A是另一个类，算一个类型 // 构造方法，接收一个 A 类型的参数 public B(A a) { this.a = a; // 使用 this 来区分成员变量 a 和参数 a } } 方法中指调用该方法的对象: 1 2 3 4 5 6 7 8 9 10 public class Baby { public void wakeUp() { System.out.println(\u0026#34;宝宝醒啦\u0026#34;); } public void eat() { this.wakeUp(); // 调用当前对象的wakeUp方法 System.out.println(\u0026#34;吃东西\u0026#34;); } } 在类本身的方法或构造器中引用该类的实例变量（全局变量）和方法: 1 2 3 4 5 public void setName(String name) { this.name = name; // 使用this关键字来区分成员变量和方法参数 //this.name是成员变量，name是方法参数 } \u0026ndash;注意\nthis 只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现 this\n\u0026ndash;原因：static 方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。\n2.12.2 super 关键字\r一句话概括：super 关键字主要存在于子类方法中，用于指向子类对象中的父类对象；可以访问父类的属性、函数以及构造函数。\n当子类和父类存在着同名的成员（包括变量和方法）时，在子类中默认是访问子类的成员，可以通过 super 关键字指定访问父类的成员。\n默认会先调用父类无参的构造方法，可以通过 super 关键字指定调用父类的构造方法。\n示例\n假设我们有一个父类 Animal 和一个子类 Dog，我们可以这样使用 super 关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Animal { String name; // 父类的构造方法 public Animal() { System.out.println(\u0026#34;Animal\u0026#39;s constructor\u0026#34;); } // 父类的方法 public void makeSound() { System.out.println(\u0026#34;Some generic animal sound\u0026#34;); } } class Dog extends Animal { // 子类的构造方法 public Dog() { super(); // 调用父类的无参构造方法 System.out.println(\u0026#34;Dog\u0026#39;s constructor\u0026#34;); } // 子类重写的方法 @Override public void makeSound() { System.out.println(\u0026#34;Woof woof\u0026#34;); } // 使用super调用父类的makeSound方法 public void specificSound() { super.makeSound(); // 调用父类的makeSound方法 System.out.println(\u0026#34;Dog\u0026#39;s specific sound\u0026#34;); } } 在这个例子中，super 关键字用于在子类 Dog 中调用父类 Animal 的构造方法和 makeSound 方法。这展示了如何在子类中访问和使用父类的成员。\n2.13.1 static 关键字\r\u0026ndash;静态变量\n1 private static String str1 = \u0026#34;staticProperty\u0026#34;; \u0026ndash;静态方法\n1 2 3 4 5 public static void print2() { System.out.println(str1); System.out.println(str2); print1(); } \u0026ndash;静态代码块\n1 2 3 static { static int a = 3; } 被 static 修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要 new 出一个类来。\n被 static 修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要 new 出一个类来。\n平时要使用类中的变量或者方法都要先new实例化一个类。\n2.13.2 final关键字\rfinal：用于声明常量、最终类或最终方法。\n\u0026ndash;修饰变量\n基本类型变量使用 final 修饰了就不可变了 对于引用类型变量被 final 修饰了；引用变量引用不可变(就整个引用变量不可变)，但是引用对象的内容可以改变。 举例\nfinal修饰数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class FinalArrayExample { public static void main(String[] args) { final int[] numbers = {1, 2, 3, 4, 5}; // 修改数组中的元素是允许的 numbers[0] = 10; // 尝试重新赋值，这将导致编译错误 // numbers = new int[]{6, 7, 8}; // 错误：不能将变量 numbers 赋值 // 输出修改后的数组 System.out.println(Arrays.toString(numbers)); // 输出: [10, 2, 3, 4, 5] } } 在这个例子中，数组 numbers 被 final 修饰，这意味着数组的引用不能被改变指向另一个数组。但是，数组中的元素可以被修改。\n\u0026ndash;修饰类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class FinalObjectExample { public static void main(String[] args) { final A obj = new A(); // 修改对象的属性是允许的，如果属性不是 final 的 obj.a = 4; // 假设 A 类中的 a 不是 final // 尝试重新赋值，这将导致编译错误 // obj = new A(); // 错误：不能将变量 obj 赋值 // 输出对象的属性值 System.out.println(obj.a); // 输出: 4 } } class A { int a = 3; } 注意\nfinal 修饰的类，不能被继承（）\n\u0026ndash;修饰方法\nfinal 修饰的方法 不能被重写，但是子类可以用父类中 final 修饰的方法；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 final class FinalClassExample { // final 类不能被继承 // 子类继承 FinalClassExample 是不允许的 public final void display() { System.out.println(\u0026#34;Hello, World!\u0026#34;); } // final 方法不能被子类重写 // 子类重写 display 方法是不允许的 } // 尝试创建子类将导致编译错误 // class SubClass extends FinalClassExample { } 2.14 抽象类\r1 2 3 4 5 6 public abstract class Action { public abstract void doSomething(); // 抽象方法 public void test() { // 方法体 } } 在这段代码中，Action 类被声明为抽象类，使用 abstract 关键字。这意味着 Action 类不能被实例化，它只能作为其他类的父类。\n抽象类可以包含抽象方法和具体方法。\n抽象方法也使用 abstract 关键字声明，它们没有方法体，必须在子类中被实现。在这个例子中，doSomething 是一个抽象方法，而 test 是一个具体方法，它提供了一个方法体。\n子类继承 Action 类时，必须实现 doSomething 方法，即要重写 doSomething 方法并添加具体的方法体。\n2.15 接口\r1 2 3 4 5 6 7 8 9 10 11 12 13 public interface UserService { // 接口中的所有定义的方法默认都是抽象的（public abstract） // 变量只能为 public static final 类型的 // public abstract void add(); // 等效于 void add(); // int age = 99; // 等效于 public static final int age = 99; int age = 99; void add(String name); void delete(String name); void update(String name); void query(String name); } 在 Java 中，接口（interface）是一种特殊的抽象类型，它可以包含抽象方法和常量。接口中的方法默认是 public abstract 的，这意味着它们没有方法体，必须由实现接口的类来提供具体实现。接口中的变量默认是 public static final 的，这意味着它们是常量，并且必须在声明时初始化。\n\u0026ndash;区别\n接口要被子类实现，抽象类要被子类继承。 接口中变量全为公共静态常量，抽象类中可有普通变量。 接口中全为抽象方法的声明，抽象类中可以有具体方法的实现。 接口中不可以有构造函数，抽象类中可以有构造函数。 一个类可实现多个接口，而抽象类只能被单继承。 接口中方法为抽象方法，而抽象类中也可有非抽象方法。 示例\n1 2 3 4 5 6 //定义接口 public interface Vehicle { void startEngine(); void stopEngine(); void honk(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //实现接口 //一旦你决定用一个类实现一个接口，你必须实现其所有的抽象方法 public class Car implements Vehicle { @Override public void startEngine() { System.out.println(\u0026#34;Car engine started.\u0026#34;); } @Override public void stopEngine() { System.out.println(\u0026#34;Car engine stopped.\u0026#34;); } @Override public void honk() { System.out.println(\u0026#34;Car horn honked.\u0026#34;); } } 1 2 3 4 5 6 7 8 9 //调用方法 public class Main { public static void main(String[] args) { Car myCar = new Car(); myCar.startEngine(); myCar.honk(); myCar.stopEngine(); } } ","date":"2024-12-16T16:04:20Z","image":"http://localhost:1313/images/Lover.PNG","permalink":"http://localhost:1313/p/quick-java/","title":"Quick Java"},{"content":"(2023-11-15) Do Users Write More Insecure Code with AI Assistants?\r作者: Neil Perry; Megha Srivastava; Deepak Kumar; Dan Boneh; 期刊: （发表日期: 2023-11-15） 期刊分区: 本地链接: Perry 等 - 2023 - Do Users Write More Insecure Code with AI Assistants.pdf DOI: 10.1145/3576915.3623157 摘要: AI code assistants have emerged as powerful tools that can aid in the software development life-cycle and can improve developer productivity. Unfortunately, such assistants have also been found to produce insecure code in lab environments, raising significant concerns about their usage in practice. In this paper, we conduct a user study to examine how users interact with AI code assistants to solve a variety of security related tasks. Overall, we find that participants who had access to an AI assistant wrote significantly less secure code than those without access to an assistant. Participants with access to an AI assistant were also more likely to believe they wrote secure code, suggesting that such tools may lead users to be overconfident about security flaws in their code. To better inform the design of future AI-based code assistants, we release our user-study apparatus and anonymized data to researchers seeking to build on our work at this link. **标签:**AI代码安全，用户行为侧 笔记日期: 2024/11/26 16:30:20 📜 研究核心\rTips: 做了什么？解决了什么问题，创新点与不足？\n研究用户如何与 AI 代码助手交互以解决各种与安全相关的任务。\n⚙️ 内容\r背景问题：AI代码助手在实验室环境中会产生不安全的代码\n研究：进行了一项用户研究，以研究用户如何与 AI 代码助手交互以解决各种与安全相关的任务。\n核心问题：\n1.用户在使用AI编程助手时是否编写了更多不安全的代码？\n2.用户是否信任AI助手能够编写安全的代码？\n3.用户在与 AI 助手交互时的语言和行为，如何影响，其代码中安全漏洞的程度？\n发现：\n1.可以访问 AI 助手的参与者编写的代码的安全性明显低于无法使用助手的参与者。\n2.有权访问 AI 助手的参与者也更有可能相信他们编写了安全代码，这表明此类工具可能会导致用户对其代码中的安全漏洞过于自信。\n💡 创新点\r从 AI代码确有问题的层面 深入到了\n1.讨论是不是 使用ai就会导致更多代码问题\n2.以及 用户对ai的信任和交互方式 和 AI生成代码问题 之间的内在联系\n🧩 不足\r研究的参与者主要是大学生，不一定能代表实际使用AI助手的开发者群体。\n而且碍于控制变量和数据收集的难度，样本数量可能确实不算太多。\n🔁 研究内容\r研究目的\n本研究旨在探讨用户在使用AI代码助手（如OpenAI的Codex）时如何解决与安全相关的编程任务，以及这种交互如何影响代码的安全性。研究主要关注三个核心问题：\n1.用户在使用AI编程助手时是否编写了更多不安全的代码？\n2.用户是否信任AI助手能够编写安全的代码？\n3.用户在与AI助手互动时的语言和行为如何影响代码中的安全漏洞程度？\n👩🏻‍💻 方法 与 🔬 实验\r实验设计\r参与者招募：\n研究招募了54名参与者，涵盖了本科生、研究生以及来自不同公司的专业程序员。参与者在参与前需通过一项筛选问题，以验证其编程能力。\n最终，有47名参与者完成了实验，其中33人使用了AI助手，14人作为对照组未使用AI助手。\n研究工具：\n为本研究定制了一个编程用户界面，实验组还配备了一个AI辅助界面，两个组别均可使用外部浏览器以解决问题。\n实验任务：\n参与者被要求完成六个与安全相关的编程问题，涉及Python、JavaScript和C语言。任务包括加密/解密字符串、签名消息、处理用户提供的路径、执行SQL操作以及处理C语言中的字符串等。参与者可以自由选择完成任务的顺序，并在两小时内完成所有问题。\n实验设计：\n参与者被随机分配到实验组（使用AI助手）和对照组（不使用AI助手）。\n研究过程中，记录了参与者的所有交互，包括查询、响应和最终提交的代码。同时，研究团队会手动分析参与者的代码，以评估其正确性和安全性。\n💧 数据\r研究团队记录了参与者在实验中的所有操作，包括代码输出和AI助手的使用情况。通过多变量回归分析，研究者控制了参与者的安全背景和编程经验，以评估AI助手对代码安全性的影响。此外，参与者在完成每个问题后还需填写简短的调查问卷，以获取他们对AI助手的信任程度及代码安全性的自我评估。\n分析过程\r研究团队详细描述了他们如何分析参与者的编程任务响应，尤其关注正确性和安全性错误的分类和评估过程。\n错误分类: 两位作者手动检查所有参与者的解决方案，创建了一个错误列表，列出了所有的正确性和安全性错误，并根据严重性对其进行了排名。\n评分标准: 研究团队设定了明确的评分标准，以衡量每个问题的正确性和安全性，\n正确性：指代码是否能成功执行预期功能；\n安全性：涉及是否存在安全漏洞。\n例如：每个问题的错误分类包括“安全”、“部分安全”、“不安全”等类别。\n注：\nCohen-Kappa一致性评分: 研究团队采用Cohen-Kappa指标（取值在-1和1间，越大一致性越高）来评估两位评审者在正确性和安全性评分上的一致性。结果显示，评分的一致性相当高，正确性评分的Kappa值在0.7至0.96之间，安全性评分的Kappa值在0.68至0.88之间，表明评分过程的可靠性。\n安全分析\r分类系统:\n研究团队为每个安全性问题设计了一个分类系统，以评估参与者的正确性和安全性，进而确定正确率和安全性错误的发生率、错误类型及其来源（来自AI助手还是用户自身）\n实验发现：\n在其中的四个问题上，可以使用人工智能助手的参与者编写的代码的安全性始终低于无法使用人工智能助手的参与者。\n统计分析:\r研究团队使用多变量回归分析来控制参与者的安全背景、编程经验等变量，以解释不同组别之间的安全性差异。\n控制变量以确保是否使用AI助手是影响代码安全的主要因素。\n信任分析\r研究者探讨了用户对AI助手作为编程辅助工具的信任程度。研究通过调查问卷、自由反馈以及用户对AI建议的采纳程度来综合评估信任这一抽象而复杂的概念。\n分析结果：\n提供答案不安全的实验组反而自我正确性和安全性评分更高；\n方案安全的信任度低，不安全的反而高；\n研究者尝试用是否直接复制AI代码来量化信任度，但是发现这因题目而异；\n大部分安全答案都是在AI代码基础上修改的，说明提供安全解决方案可能需要用户更有意识地修改AI生成的代码，而不是盲目信任AI生成的内容。\n提示分析\r研究者探讨了用户如何与AI代码助手进行交互，具体分析了用户的提示语言、提示参数和修复策略对代码安全性的影响。\n分析结果\n提示语言\n使用函数声明和帮助函数的提示更能生成安全的代码。\n提示类型的选择对代码的安全性有显著影响，部分参与者在与AI助手的互动中使用了前一个AI输出作为新提示，这可能导致安全问题的放大或重复。\n提示参数的调整\n调整温度参数可能对代码的安全性产生影响，使用更高的温度值通常与更安全的代码输出相关。\n修复策略\n参与者在修复提示时更倾向于使用更具体的指令和信息。\n安全性\n依赖于AI助手的先前输出进行后续提示的参与者，往往不太可能提供安全答案。这表明，过度依赖AI生成的内容可能导致安全性下降。\n📜 结论总结\rAI助手的影响\r（同时也是核心问题1的回答）\n研究发现，参与者在使用AI助手时，通常会引入更多的安全漏洞。大多数任务中，使用AI助手的参与者更可能提交不安全的解决方案，而那些没有使用助手的参与者则相对更安全。这表明AI助手可能导致开发者对其生成的代码过于信任，从而忽视潜在的安全问题。\n用户信任与安全性的关系\r参与者普遍认为他们的答案更安全，尤其是那些提交不安全代码的用户，相比之下，提交安全代码的用户对AI助手的信任度较低。这种反向关系特别明显，显示出用户在面对AI生成的代码时可能会产生误导性的安全感。\n用户行为的多样性\r参与者在与AI助手互动时展现出显著的行为差异。那些更加积极调整提示或参数的参与者，通常能提供更安全的解决方案。这表明用户的交互策略和对AI助手的理解程度直接影响了他们最终的代码安全性。\nAI助手的设计建议\r研究者建议未来的AI助手设计应加强对用户的教育，帮助他们理解如何有效地与AI进行交互，避免过度依赖助手的输出。\n同时，应该考虑在AI助手中集成安全警示和验证测试，以减少用户在使用过程中产生的安全漏洞。\n研究的局限性\r研究的参与者主要是大学生，这可能不代表实际使用AI助手的开发者群体。研究者指出，未来需要更大规模的样本和不同背景的参与者，以更全面地评估AI助手在实际开发环境中的影响。\n小结\r总的来说，该总结部分强调了AI助手在提高开发效率的同时，也可能引入安全风险，用户应更加谨慎地对待AI生成的代码，未来的AI助手设计需要考虑如何增强用户的安全意识和代码审查能力。\n🤔 个人总结\r🙋‍♀️重点记录\ridea的创新之处\n从 AI代码确有问题的层面 深入到了\n1.讨论是不是 使用ai就会导致更多代码问题；\n2.以及 用户对ai的信任和交互方式 和 AI生成代码问题 之间的内在联系。\n在现有的研究上更加深入，具体地探讨了影响 AI生成代码安全问题的 用户因素。\n控制变量的处理\n要确保实验反映的确实是AI代码助手的影响，需要把其它实验变量控制在可控范围内，尽量消除它们对关键要素的判断的影响。\n不足\n研究的参与者主要是大学生，不一定能代表实际使用AI助手的开发者群体。\n而且碍于控制变量和数据收集的难度，样本数量可能确实不算太多。\n启发\r这篇文章是从用户端分析的AI生成代码安全的问题，我觉得从模型端的角度也可以对AI代码安全问题进行分析。虽然感觉实现难度上可能要大得多了。\n","date":"2024-11-23T21:45:04Z","image":"http://localhost:1313/images/Tiger.JPG","permalink":"http://localhost:1313/p/do-users-write-more-insecure-code-with-ai-assistants/","title":"Do Users Write More Insecure Code with AI Assistants?"},{"content":"Typora教程\rTypora的安装\r这是b站up主 格格分享集 提供的1.9.5版本及绕过激活方法，在此鸣谢。\nhttps://www.bilibili.com/video/BV1iKUsYdEat/?share_source=copy_web\u0026vd_source=94c6a60e88fb8109fcdee4173a2a7281\n不想看视频的可以往下看。\n解压 Typora1.9.5.zip后，文件结构如下：\n先运行安装程序安装typora1.9.5；\n然后解压河蟹.zip,将其中的配置文件winmm.dll复制到typora所在文件夹(右键点击typora快捷方式即可)；\n最后打开typora，点击侧边栏中的帮助，再点击关于激活即可。\nMarkdown语法及Typora快捷键\r标题\r使用井号 # 后接文本表标题，#个数表示几级标题，至多六级。（有时#后要紧接空格）\nTypora中快捷键Ctrl+1-6表示相应级标题。\n字体\r斜体\r一对星号*括住的文本表示斜体文本。\n要表示斜体的文本\n或者用一对下划线_括住文本表示斜体文本。\n要表示斜体的文本\nTypora快捷键Ctrl+I。\n粗体\r一对 ** 括住的文本表示斜体文本。\n要表示斜体的文本\n或者用一对下划线 __ 括住文本表示斜体文本。\n要表示斜体的文本\nTypora快捷键Ctrl+B。\n粗斜体文本\r一对 *** 括住的文本表示斜体文本。\n要表示粗斜体的文本\n或者用一对下划线 __ 括住文本表示斜体文本。\n要表示斜体的文本\n文本高亮\r算是Typora的一个特色，用一对==将要高亮的文本括起来，需要在文件-偏好设置中打开。\n==要高亮的文本==\n各种线\r分割线\r用三个及以上的 + 号或 * 号或 - 来表示一条分割线；\nTypora右键插入水平分割线即可。\n下为例子：\n+++\n下划线\r利用的是HTML的标签 和 表示增加下划线文本，\n要增加下划线的文本\nTypora快捷键：Ctrl+U\n删除线\r用一对~~括住的文本来表示删除文本；\n要删除的文本\nTypora快捷键：Alt+Shift+5\n表格\rMarkdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\nTypora快捷键：Ctrl+T\nTypora中表格的创建和修改都非常精简和方便，所以很多额外的操作（对齐、添加行列等）不加赘述了。\n表头 表头 表头 列表\r无序列表\r用*，+或-标记符号来表示无序列表项，标记符号后要紧接一个空格。\n1 2 其它两符号同上。\n（Enter键退出列表）\nTypora快捷键：Ctrl+Shift+] (更建议右键里添加)\n有序列表\r以 数字紧接.再紧接空格表示有序列表。\n一 二 Typora快捷键：Ctrl+Shift+[ (更建议右键里添加)\n嵌套列表\r列表中：\n回车换行自动生成列表第二列；\nTab键该项变为上一项的子列表。\n无序列表和有序列表间可相互嵌套。\n引用\r用区块表引用, \u0026gt;加空格表示区块。\n这是一级引用\n这是二级引用\n（Enter键退出区块）\nTypora快捷键：Ctrl+Shift+Q (更建议右键里添加)\n代码块\r代码行：用一对**`**（英语下Tab键上方符号）括住代码\nprint(\u0026quot;Helloworld\u0026quot;)\n代码块：\n以三个`加回车进入代码块；\nTypora快捷键：Ctrl+Shift+`\n链接\r用\n链接文字\n或\n\u0026lt;链接地址\u0026gt;\n表示链接。\n[]中是链接文本，\u0026lt;\u0026gt;中是链接地址，也可以放本地文件的地址（相对绝对均可）\n但是单独使用\u0026lt;\u0026gt;不能打开文件。\n亦可使用链接实现页内跳转：\n链接文字\nCTRL+点击跳转至文章开头\n图像\r语法如下：\n！加[属性文本]加(图片地址 ”可选标题“)\n首先一个感叹号 然后中括号里面写属性文本 小括号里面写图片地址，后可接标题 本地地址和网络地址都行。\n在Typora中，也可以直接使用Ctrl+C，Ctrl+V来直接进行复制粘贴图片，但是，由于Markdown语法的限制，一定需要文件地址，所以需要设置一下Typora。\n在Typora 文件-偏好设置-图像 中可自行选择将图片复制到什么路径。相对路径以该文本文件为参照。\n数学\r数学公式太繁琐了喵，推荐让ai生成，这里不加赘述了。\n有时间再更。\n","date":"2024-11-23T21:45:04Z","image":"http://localhost:1313/images/PacificRim_01.jpg","permalink":"http://localhost:1313/p/typora/","title":"Typora"}]